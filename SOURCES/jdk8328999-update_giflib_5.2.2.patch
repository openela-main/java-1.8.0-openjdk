diff --git a/THIRD_PARTY_README b/THIRD_PARTY_README
index f9aea78d64..605b36f100 100644
--- a/THIRD_PARTY_README
+++ b/THIRD_PARTY_README
@@ -1696,7 +1696,7 @@ released under other open source licenses.
 
 -------------------------------------------------------------------------------
 
-%% This notice is provided with respect to GIFLIB 5.2.1 & libungif 4.1.3, 
+%% This notice is provided with respect to GIFLIB 5.2.2 & libungif 4.1.3,
 which may be included with JRE 8, JDK 8, and OpenJDK 8.
 
 --- begin of LICENSE ---
@@ -1721,6 +1721,29 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 
+tree/README
+
+== Authors ==
+
+Gershon Elber <gershon[AT]cs.technion.sc.il>
+original giflib code
+
+Toshio Kuratomi <toshio[AT]tiki-lounge.com>
+uncompressed gif writing code
+former maintainer
+
+Eric Raymond <esr[AT]snark.thyrsus.com>
+current as well as long time former maintainer of giflib code
+
+There have been many other contributors; see the attributions in the
+version-control history to learn more.
+
+
+tree/openbsd-reallocarray.c
+
+Copyright (C) 2008 Otto Moerbeek <otto@drijf.net>
+SPDX-License-Identifier: MIT
+
 --- end of LICENSE ---
 
 -------------------------------------------------------------------------------
diff --git a/jdk/src/share/native/sun/awt/giflib/dgif_lib.c b/jdk/src/share/native/sun/awt/giflib/dgif_lib.c
index 6ddfb46060..0b2860b4b5 100644
--- a/jdk/src/share/native/sun/awt/giflib/dgif_lib.c
+++ b/jdk/src/share/native/sun/awt/giflib/dgif_lib.c
@@ -34,11 +34,11 @@ SPDX-License-Identifier: MIT
 
 *****************************************************************************/
 
-#include <stdlib.h>
+#include <fcntl.h>
 #include <limits.h>
 #include <stdint.h>
-#include <fcntl.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 
 #ifdef _WIN32
@@ -55,18 +55,19 @@ SPDX-License-Identifier: MIT
 
 /* avoid extra function call in case we use fread (TVT) */
 static int InternalRead(GifFileType *gif, GifByteType *buf, int len) {
-    //fprintf(stderr, "### Read: %d\n", len);
-    return
-    (((GifFilePrivateType*)gif->Private)->Read ?
-     ((GifFilePrivateType*)gif->Private)->Read(gif,buf,len) :
-     fread(buf,1,len,((GifFilePrivateType*)gif->Private)->File));
+    // fprintf(stderr, "### Read: %d\n", len);
+    return (((GifFilePrivateType *)gif->Private)->Read
+                ? ((GifFilePrivateType *)gif->Private)->Read(gif, buf, len)
+                : fread(buf, 1, len,
+                        ((GifFilePrivateType *)gif->Private)->File));
 }
 
 static int DGifGetWord(GifFileType *GifFile, GifWord *Word);
 static int DGifSetupDecompress(GifFileType *GifFile);
 static int DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line,
                               int LineLen);
-static int DGifGetPrefixChar(GifPrefixType *Prefix, int Code, int ClearCode);
+static int DGifGetPrefixChar(const GifPrefixType *Prefix, int Code,
+                             int ClearCode);
 static int DGifDecompressInput(GifFileType *GifFile, int *Code);
 static int DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf,
                              GifByteType *NextByte);
@@ -76,15 +77,14 @@ static int DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf,
  Returns dynamically allocated GifFileType pointer which serves as the GIF
  info record.
 ******************************************************************************/
-GifFileType *
-DGifOpenFileName(const char *FileName, int *Error)
-{
+GifFileType *DGifOpenFileName(const char *FileName, int *Error) {
     int FileHandle;
     GifFileType *GifFile;
 
     if ((FileHandle = open(FileName, O_RDONLY)) == -1) {
-        if (Error != NULL)
+        if (Error != NULL) {
             *Error = D_GIF_ERR_OPEN_FAILED;
+        }
         return NULL;
     }
 
@@ -97,9 +97,7 @@ DGifOpenFileName(const char *FileName, int *Error)
  Returns dynamically allocated GifFileType pointer which serves as the GIF
  info record.
 ******************************************************************************/
-GifFileType *
-DGifOpenFileHandle(int FileHandle, int *Error)
-{
+GifFileType *DGifOpenFileHandle(int FileHandle, int *Error) {
     char Buf[GIF_STAMP_LEN + 1];
     GifFileType *GifFile;
     GifFilePrivateType *Private;
@@ -107,13 +105,14 @@ DGifOpenFileHandle(int FileHandle, int *Error)
 
     GifFile = (GifFileType *)malloc(sizeof(GifFileType));
     if (GifFile == NULL) {
-        if (Error != NULL)
+        if (Error != NULL) {
             *Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+        }
         (void)close(FileHandle);
         return NULL;
     }
 
-    /*@i1@*/memset(GifFile, '\0', sizeof(GifFileType));
+    /*@i1@*/ memset(GifFile, '\0', sizeof(GifFileType));
 
     /* Belt and suspenders, in case the null pointer isn't zero */
     GifFile->SavedImages = NULL;
@@ -121,35 +120,38 @@ DGifOpenFileHandle(int FileHandle, int *Error)
 
     Private = (GifFilePrivateType *)calloc(1, sizeof(GifFilePrivateType));
     if (Private == NULL) {
-        if (Error != NULL)
+        if (Error != NULL) {
             *Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+        }
         (void)close(FileHandle);
         free((char *)GifFile);
         return NULL;
     }
 
-    /*@i1@*/memset(Private, '\0', sizeof(GifFilePrivateType));
+    /*@i1@*/ memset(Private, '\0', sizeof(GifFilePrivateType));
 
 #ifdef _WIN32
-    _setmode(FileHandle, O_BINARY);    /* Make sure it is in binary mode. */
-#endif /* _WIN32 */
+    _setmode(FileHandle, O_BINARY); /* Make sure it is in binary mode. */
+#endif                                  /* _WIN32 */
 
-    f = fdopen(FileHandle, "rb");    /* Make it into a stream: */
+    f = fdopen(FileHandle, "rb"); /* Make it into a stream: */
 
     /*@-mustfreeonly@*/
     GifFile->Private = (void *)Private;
     Private->FileHandle = FileHandle;
     Private->File = f;
     Private->FileState = FILE_STATE_READ;
-    Private->Read = NULL;        /* don't use alternate input method (TVT) */
-    GifFile->UserData = NULL;    /* TVT */
+    Private->Read = NULL;     /* don't use alternate input method (TVT) */
+    GifFile->UserData = NULL; /* TVT */
     /*@=mustfreeonly@*/
 
     /* Let's see if this is a GIF file: */
     /* coverity[check_return] */
-    if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {
-        if (Error != NULL)
+    if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) !=
+        GIF_STAMP_LEN) {
+        if (Error != NULL) {
             *Error = D_GIF_ERR_READ_FAILED;
+        }
         (void)fclose(f);
         free((char *)Private);
         free((char *)GifFile);
@@ -159,8 +161,9 @@ DGifOpenFileHandle(int FileHandle, int *Error)
     /* Check for GIF prefix at start of file */
     Buf[GIF_STAMP_LEN] = 0;
     if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {
-        if (Error != NULL)
+        if (Error != NULL) {
             *Error = D_GIF_ERR_NOT_GIF_FILE;
+        }
         (void)fclose(f);
         free((char *)Private);
         free((char *)GifFile);
@@ -177,7 +180,7 @@ DGifOpenFileHandle(int FileHandle, int *Error)
     GifFile->Error = 0;
 
     /* What version of GIF? */
-    Private->gif89 = (Buf[GIF_VERSION_POS] == '9');
+    Private->gif89 = (Buf[GIF_VERSION_POS + 1] == '9');
 
     return GifFile;
 }
@@ -185,17 +188,16 @@ DGifOpenFileHandle(int FileHandle, int *Error)
 /******************************************************************************
  GifFileType constructor with user supplied input function (TVT)
 ******************************************************************************/
-GifFileType *
-DGifOpen(void *userData, InputFunc readFunc, int *Error)
-{
+GifFileType *DGifOpen(void *userData, InputFunc readFunc, int *Error) {
     char Buf[GIF_STAMP_LEN + 1];
     GifFileType *GifFile;
     GifFilePrivateType *Private;
 
     GifFile = (GifFileType *)malloc(sizeof(GifFileType));
     if (GifFile == NULL) {
-        if (Error != NULL)
+        if (Error != NULL) {
             *Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+        }
         return NULL;
     }
 
@@ -207,26 +209,29 @@ DGifOpen(void *userData, InputFunc readFunc, int *Error)
 
     Private = (GifFilePrivateType *)calloc(1, sizeof(GifFilePrivateType));
     if (!Private) {
-        if (Error != NULL)
+        if (Error != NULL) {
             *Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+        }
         free((char *)GifFile);
         return NULL;
     }
-    /*@i1@*/memset(Private, '\0', sizeof(GifFilePrivateType));
+    /*@i1@*/ memset(Private, '\0', sizeof(GifFilePrivateType));
 
     GifFile->Private = (void *)Private;
     Private->FileHandle = 0;
     Private->File = NULL;
     Private->FileState = FILE_STATE_READ;
 
-    Private->Read = readFunc;    /* TVT */
-    GifFile->UserData = userData;    /* TVT */
+    Private->Read = readFunc;     /* TVT */
+    GifFile->UserData = userData; /* TVT */
 
     /* Lets see if this is a GIF file: */
     /* coverity[check_return] */
-    if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {
-        if (Error != NULL)
+    if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) !=
+        GIF_STAMP_LEN) {
+        if (Error != NULL) {
             *Error = D_GIF_ERR_READ_FAILED;
+        }
         free((char *)Private);
         free((char *)GifFile);
         return NULL;
@@ -235,8 +240,9 @@ DGifOpen(void *userData, InputFunc readFunc, int *Error)
     /* Check for GIF prefix at start of file */
     Buf[GIF_STAMP_LEN] = '\0';
     if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {
-        if (Error != NULL)
+        if (Error != NULL) {
             *Error = D_GIF_ERR_NOT_GIF_FILE;
+        }
         free((char *)Private);
         free((char *)GifFile);
         return NULL;
@@ -245,15 +251,16 @@ DGifOpen(void *userData, InputFunc readFunc, int *Error)
     if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {
         free((char *)Private);
         free((char *)GifFile);
-        if (Error != NULL)
+        if (Error != NULL) {
             *Error = D_GIF_ERR_NO_SCRN_DSCR;
+        }
         return NULL;
     }
 
     GifFile->Error = 0;
 
     /* What version of GIF? */
-    Private->gif89 = (Buf[GIF_VERSION_POS] == '9');
+    Private->gif89 = (Buf[GIF_VERSION_POS + 1] == '9');
 
     return GifFile;
 }
@@ -262,9 +269,7 @@ DGifOpen(void *userData, InputFunc readFunc, int *Error)
  This routine should be called before any other DGif calls. Note that
  this routine is called automatically from DGif file open routines.
 ******************************************************************************/
-int
-DGifGetScreenDesc(GifFileType *GifFile)
-{
+int DGifGetScreenDesc(GifFileType *GifFile) {
     int BitsPerPixel;
     bool SortFlag;
     GifByteType Buf[3];
@@ -278,8 +283,9 @@ DGifGetScreenDesc(GifFileType *GifFile)
 
     /* Put the screen descriptor into the file: */
     if (DGifGetWord(GifFile, &GifFile->SWidth) == GIF_ERROR ||
-        DGifGetWord(GifFile, &GifFile->SHeight) == GIF_ERROR)
+        DGifGetWord(GifFile, &GifFile->SHeight) == GIF_ERROR) {
         return GIF_ERROR;
+    }
 
     if (InternalRead(GifFile, Buf, 3) != 3) {
         GifFile->Error = D_GIF_ERR_READ_FAILED;
@@ -292,7 +298,7 @@ DGifGetScreenDesc(GifFileType *GifFile)
     BitsPerPixel = (Buf[0] & 0x07) + 1;
     GifFile->SBackGroundColor = Buf[1];
     GifFile->AspectByte = Buf[2];
-    if (Buf[0] & 0x80) {    /* Do we have global color map? */
+    if (Buf[0] & 0x80) { /* Do we have global color map? */
         int i;
 
         GifFile->SColorMap = GifMakeMapObject(1 << BitsPerPixel, NULL);
@@ -327,23 +333,20 @@ DGifGetScreenDesc(GifFileType *GifFile)
     return GIF_OK;
 }
 
-const char *
-DGifGetGifVersion(GifFileType *GifFile)
-{
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
+const char *DGifGetGifVersion(GifFileType *GifFile) {
+    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
-    if (Private->gif89)
+    if (Private->gif89) {
         return GIF89_STAMP;
-    else
+    } else {
         return GIF87_STAMP;
+    }
 }
 
 /******************************************************************************
  This routine should be called before any attempt to read an image.
 ******************************************************************************/
-int
-DGifGetRecordType(GifFileType *GifFile, GifRecordType* Type)
-{
+int DGifGetRecordType(GifFileType *GifFile, GifRecordType *Type) {
     GifByteType Buf;
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
@@ -359,29 +362,27 @@ DGifGetRecordType(GifFileType *GifFile, GifRecordType* Type)
         return GIF_ERROR;
     }
 
-    //fprintf(stderr, "### DGifGetRecordType: %02x\n", Buf);
+    // fprintf(stderr, "### DGifGetRecordType: %02x\n", Buf);
     switch (Buf) {
-      case DESCRIPTOR_INTRODUCER:
-          *Type = IMAGE_DESC_RECORD_TYPE;
-          break;
-      case EXTENSION_INTRODUCER:
-          *Type = EXTENSION_RECORD_TYPE;
-          break;
-      case TERMINATOR_INTRODUCER:
-          *Type = TERMINATE_RECORD_TYPE;
-          break;
-      default:
-          *Type = UNDEFINED_RECORD_TYPE;
-          GifFile->Error = D_GIF_ERR_WRONG_RECORD;
-          return GIF_ERROR;
+    case DESCRIPTOR_INTRODUCER:
+        *Type = IMAGE_DESC_RECORD_TYPE;
+        break;
+    case EXTENSION_INTRODUCER:
+        *Type = EXTENSION_RECORD_TYPE;
+        break;
+    case TERMINATOR_INTRODUCER:
+        *Type = TERMINATE_RECORD_TYPE;
+        break;
+    default:
+        *Type = UNDEFINED_RECORD_TYPE;
+        GifFile->Error = D_GIF_ERR_WRONG_RECORD;
+        return GIF_ERROR;
     }
 
     return GIF_OK;
 }
 
-int
-DGifGetImageHeader(GifFileType *GifFile)
-{
+int DGifGetImageHeader(GifFileType *GifFile) {
     unsigned int BitsPerPixel;
     GifByteType Buf[3];
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
@@ -395,8 +396,9 @@ DGifGetImageHeader(GifFileType *GifFile)
     if (DGifGetWord(GifFile, &GifFile->Image.Left) == GIF_ERROR ||
         DGifGetWord(GifFile, &GifFile->Image.Top) == GIF_ERROR ||
         DGifGetWord(GifFile, &GifFile->Image.Width) == GIF_ERROR ||
-        DGifGetWord(GifFile, &GifFile->Image.Height) == GIF_ERROR)
+        DGifGetWord(GifFile, &GifFile->Image.Height) == GIF_ERROR) {
         return GIF_ERROR;
+    }
     if (InternalRead(GifFile, Buf, 1) != 1) {
         GifFile->Error = D_GIF_ERR_READ_FAILED;
         GifFreeMapObject(GifFile->Image.ColorMap);
@@ -415,7 +417,8 @@ DGifGetImageHeader(GifFileType *GifFile)
     if (Buf[0] & 0x80) {
         unsigned int i;
 
-        GifFile->Image.ColorMap = GifMakeMapObject(1 << BitsPerPixel, NULL);
+        GifFile->Image.ColorMap =
+            GifMakeMapObject(1 << BitsPerPixel, NULL);
         if (GifFile->Image.ColorMap == NULL) {
             GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
             return GIF_ERROR;
@@ -436,8 +439,8 @@ DGifGetImageHeader(GifFileType *GifFile)
         }
     }
 
-    Private->PixelCount = (long)GifFile->Image.Width *
-       (long)GifFile->Image.Height;
+    Private->PixelCount =
+        (long)GifFile->Image.Width * (long)GifFile->Image.Height;
 
     /* Reset decompress algorithm parameters. */
     return DGifSetupDecompress(GifFile);
@@ -447,9 +450,7 @@ DGifGetImageHeader(GifFileType *GifFile)
  This routine should be called before any attempt to read an image.
  Note it is assumed the Image desc. header has been read.
 ******************************************************************************/
-int
-DGifGetImageDesc(GifFileType *GifFile)
-{
+int DGifGetImageDesc(GifFileType *GifFile) {
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
     SavedImage *sp;
 
@@ -464,9 +465,9 @@ DGifGetImageDesc(GifFileType *GifFile)
     }
 
     if (GifFile->SavedImages) {
-        SavedImage* new_saved_images =
-            (SavedImage *)reallocarray(GifFile->SavedImages,
-                            (GifFile->ImageCount + 1), sizeof(SavedImage));
+        SavedImage *new_saved_images = (SavedImage *)reallocarray(
+            GifFile->SavedImages, (GifFile->ImageCount + 1),
+            sizeof(SavedImage));
         if (new_saved_images == NULL) {
             GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
             return GIF_ERROR;
@@ -474,7 +475,7 @@ DGifGetImageDesc(GifFileType *GifFile)
         GifFile->SavedImages = new_saved_images;
     } else {
         if ((GifFile->SavedImages =
-             (SavedImage *) malloc(sizeof(SavedImage))) == NULL) {
+                 (SavedImage *)malloc(sizeof(SavedImage))) == NULL) {
             GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
             return GIF_ERROR;
         }
@@ -483,9 +484,9 @@ DGifGetImageDesc(GifFileType *GifFile)
     sp = &GifFile->SavedImages[GifFile->ImageCount];
     memcpy(&sp->ImageDesc, &GifFile->Image, sizeof(GifImageDesc));
     if (GifFile->Image.ColorMap != NULL) {
-        sp->ImageDesc.ColorMap = GifMakeMapObject(
-                                 GifFile->Image.ColorMap->ColorCount,
-                                 GifFile->Image.ColorMap->Colors);
+        sp->ImageDesc.ColorMap =
+            GifMakeMapObject(GifFile->Image.ColorMap->ColorCount,
+                             GifFile->Image.ColorMap->Colors);
         if (sp->ImageDesc.ColorMap == NULL) {
             GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
             return GIF_ERROR;
@@ -493,7 +494,7 @@ DGifGetImageDesc(GifFileType *GifFile)
     }
     sp->RasterBits = (unsigned char *)NULL;
     sp->ExtensionBlockCount = 0;
-    sp->ExtensionBlocks = (ExtensionBlock *) NULL;
+    sp->ExtensionBlocks = (ExtensionBlock *)NULL;
 
     GifFile->ImageCount++;
 
@@ -503,11 +504,9 @@ DGifGetImageDesc(GifFileType *GifFile)
 /******************************************************************************
  Get one full scanned line (Line) of length LineLen from GIF file.
 ******************************************************************************/
-int
-DGifGetLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
-{
+int DGifGetLine(GifFileType *GifFile, GifPixelType *Line, int LineLen) {
     GifByteType *Dummy;
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
+    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
     if (!IS_READABLE(Private)) {
         /* This file was NOT open for reading: */
@@ -515,8 +514,9 @@ DGifGetLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
         return GIF_ERROR;
     }
 
-    if (!LineLen)
+    if (!LineLen) {
         LineLen = GifFile->Image.Width;
+    }
 
     if ((Private->PixelCount -= LineLen) > 0xffff0000UL) {
         GifFile->Error = D_GIF_ERR_DATA_TOO_BIG;
@@ -525,56 +525,59 @@ DGifGetLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
 
     if (DGifDecompressLine(GifFile, Line, LineLen) == GIF_OK) {
         if (Private->PixelCount == 0) {
-            /* We probably won't be called any more, so let's clean up
-             * everything before we return: need to flush out all the
-             * rest of image until an empty block (size 0)
+            /* We probably won't be called any more, so let's clean
+             * up everything before we return: need to flush out all
+             * the rest of image until an empty block (size 0)
              * detected. We use GetCodeNext.
              */
-            do
-                if (DGifGetCodeNext(GifFile, &Dummy) == GIF_ERROR)
+            do {
+                if (DGifGetCodeNext(GifFile, &Dummy) ==
+                    GIF_ERROR) {
                     return GIF_ERROR;
-            while (Dummy != NULL) ;
+                }
+            } while (Dummy != NULL);
         }
         return GIF_OK;
-    } else
+    } else {
         return GIF_ERROR;
+    }
 }
 
 /******************************************************************************
  Put one pixel (Pixel) into GIF file.
 ******************************************************************************/
-int
-DGifGetPixel(GifFileType *GifFile, GifPixelType Pixel)
-{
+int DGifGetPixel(GifFileType *GifFile, GifPixelType Pixel) {
     GifByteType *Dummy;
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
+    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
     if (!IS_READABLE(Private)) {
         /* This file was NOT open for reading: */
         GifFile->Error = D_GIF_ERR_NOT_READABLE;
         return GIF_ERROR;
     }
-    if (--Private->PixelCount > 0xffff0000UL)
-    {
+    if (--Private->PixelCount > 0xffff0000UL) {
         GifFile->Error = D_GIF_ERR_DATA_TOO_BIG;
         return GIF_ERROR;
     }
 
     if (DGifDecompressLine(GifFile, &Pixel, 1) == GIF_OK) {
         if (Private->PixelCount == 0) {
-            /* We probably won't be called any more, so let's clean up
-             * everything before we return: need to flush out all the
-             * rest of image until an empty block (size 0)
+            /* We probably won't be called any more, so let's clean
+             * up everything before we return: need to flush out all
+             * the rest of image until an empty block (size 0)
              * detected. We use GetCodeNext.
              */
-            do
-                if (DGifGetCodeNext(GifFile, &Dummy) == GIF_ERROR)
+            do {
+                if (DGifGetCodeNext(GifFile, &Dummy) ==
+                    GIF_ERROR) {
                     return GIF_ERROR;
-            while (Dummy != NULL) ;
+                }
+            } while (Dummy != NULL);
         }
         return GIF_OK;
-    } else
+    } else {
         return GIF_ERROR;
+    }
 }
 
 /******************************************************************************
@@ -584,13 +587,12 @@ DGifGetPixel(GifFileType *GifFile, GifPixelType Pixel)
  The Extension should NOT be freed by the user (not dynamically allocated).
  Note it is assumed the Extension description header has been read.
 ******************************************************************************/
-int
-DGifGetExtension(GifFileType *GifFile, int *ExtCode, GifByteType **Extension)
-{
+int DGifGetExtension(GifFileType *GifFile, int *ExtCode,
+                     GifByteType **Extension) {
     GifByteType Buf;
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
-    //fprintf(stderr, "### -> DGifGetExtension:\n");
+    // fprintf(stderr, "### -> DGifGetExtension:\n");
     if (!IS_READABLE(Private)) {
         /* This file was NOT open for reading: */
         GifFile->Error = D_GIF_ERR_NOT_READABLE;
@@ -603,7 +605,8 @@ DGifGetExtension(GifFileType *GifFile, int *ExtCode, GifByteType **Extension)
         return GIF_ERROR;
     }
     *ExtCode = Buf;
-    //fprintf(stderr, "### <- DGifGetExtension: %02x, about to call next\n", Buf);
+    // fprintf(stderr, "### <- DGifGetExtension: %02x, about to call
+    // next\n", Buf);
 
     return DGifGetExtensionNext(GifFile, Extension);
 }
@@ -613,30 +616,30 @@ DGifGetExtension(GifFileType *GifFile, int *ExtCode, GifByteType **Extension)
  routine should be called until NULL Extension is returned.
  The Extension should NOT be freed by the user (not dynamically allocated).
 ******************************************************************************/
-int
-DGifGetExtensionNext(GifFileType *GifFile, GifByteType ** Extension)
-{
+int DGifGetExtensionNext(GifFileType *GifFile, GifByteType **Extension) {
     GifByteType Buf;
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
-    //fprintf(stderr, "### -> DGifGetExtensionNext\n");
+    // fprintf(stderr, "### -> DGifGetExtensionNext\n");
     if (InternalRead(GifFile, &Buf, 1) != 1) {
         GifFile->Error = D_GIF_ERR_READ_FAILED;
         return GIF_ERROR;
     }
-    //fprintf(stderr, "### DGifGetExtensionNext sees %d\n", Buf);
+    // fprintf(stderr, "### DGifGetExtensionNext sees %d\n", Buf);
 
     if (Buf > 0) {
-        *Extension = Private->Buf;    /* Use private unused buffer. */
-        (*Extension)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */
-        /* coverity[tainted_data,check_return] */
+        *Extension = Private->Buf; /* Use private unused buffer. */
+        (*Extension)[0] =
+            Buf; /* Pascal strings notation (pos. 0 is len.). */
+                 /* coverity[tainted_data,check_return] */
         if (InternalRead(GifFile, &((*Extension)[1]), Buf) != Buf) {
             GifFile->Error = D_GIF_ERR_READ_FAILED;
             return GIF_ERROR;
         }
-    } else
+    } else {
         *Extension = NULL;
-    //fprintf(stderr, "### <- DGifGetExtensionNext: %p\n", Extension);
+    }
+    // fprintf(stderr, "### <- DGifGetExtensionNext: %p\n", Extension);
 
     return GIF_OK;
 }
@@ -647,19 +650,20 @@ DGifGetExtensionNext(GifFileType *GifFile, GifByteType ** Extension)
 
 int DGifExtensionToGCB(const size_t GifExtensionLength,
                        const GifByteType *GifExtension,
-                       GraphicsControlBlock *GCB)
-{
+                       GraphicsControlBlock *GCB) {
     if (GifExtensionLength != 4) {
         return GIF_ERROR;
     }
 
     GCB->DisposalMode = (GifExtension[0] >> 2) & 0x07;
     GCB->UserInputFlag = (GifExtension[0] & 0x02) != 0;
-    GCB->DelayTime = UNSIGNED_LITTLE_ENDIAN(GifExtension[1], GifExtension[2]);
-    if (GifExtension[0] & 0x01)
+    GCB->DelayTime =
+        UNSIGNED_LITTLE_ENDIAN(GifExtension[1], GifExtension[2]);
+    if (GifExtension[0] & 0x01) {
         GCB->TransparentColor = (int)GifExtension[3];
-    else
+    } else {
         GCB->TransparentColor = NO_TRANSPARENT_COLOR;
+    }
 
     return GIF_OK;
 }
@@ -668,23 +672,27 @@ int DGifExtensionToGCB(const size_t GifExtensionLength,
  Extract the Graphics Control Block for a saved image, if it exists.
 ******************************************************************************/
 
-int DGifSavedExtensionToGCB(GifFileType *GifFile,
-                int ImageIndex, GraphicsControlBlock *GCB)
-{
+int DGifSavedExtensionToGCB(GifFileType *GifFile, int ImageIndex,
+                            GraphicsControlBlock *GCB) {
     int i;
 
-    if (ImageIndex < 0 || ImageIndex > GifFile->ImageCount - 1)
+    if (ImageIndex < 0 || ImageIndex > GifFile->ImageCount - 1) {
         return GIF_ERROR;
+    }
 
     GCB->DisposalMode = DISPOSAL_UNSPECIFIED;
     GCB->UserInputFlag = false;
     GCB->DelayTime = 0;
     GCB->TransparentColor = NO_TRANSPARENT_COLOR;
 
-    for (i = 0; i < GifFile->SavedImages[ImageIndex].ExtensionBlockCount; i++) {
-        ExtensionBlock *ep = &GifFile->SavedImages[ImageIndex].ExtensionBlocks[i];
-        if (ep->Function == GRAPHICS_EXT_FUNC_CODE)
-            return DGifExtensionToGCB(ep->ByteCount, ep->Bytes, GCB);
+    for (i = 0; i < GifFile->SavedImages[ImageIndex].ExtensionBlockCount;
+         i++) {
+        ExtensionBlock *ep =
+            &GifFile->SavedImages[ImageIndex].ExtensionBlocks[i];
+        if (ep->Function == GRAPHICS_EXT_FUNC_CODE) {
+            return DGifExtensionToGCB(ep->ByteCount, ep->Bytes,
+                                      GCB);
+        }
     }
 
     return GIF_ERROR;
@@ -693,13 +701,12 @@ int DGifSavedExtensionToGCB(GifFileType *GifFile,
 /******************************************************************************
  This routine should be called last, to close the GIF file.
 ******************************************************************************/
-int
-DGifCloseFile(GifFileType *GifFile, int *ErrorCode)
-{
+int DGifCloseFile(GifFileType *GifFile, int *ErrorCode) {
     GifFilePrivateType *Private;
 
-    if (GifFile == NULL || GifFile->Private == NULL)
+    if (GifFile == NULL || GifFile->Private == NULL) {
         return GIF_ERROR;
+    }
 
     if (GifFile->Image.ColorMap) {
         GifFreeMapObject(GifFile->Image.ColorMap);
@@ -716,22 +723,25 @@ DGifCloseFile(GifFileType *GifFile, int *ErrorCode)
         GifFile->SavedImages = NULL;
     }
 
-    GifFreeExtensions(&GifFile->ExtensionBlockCount, &GifFile->ExtensionBlocks);
+    GifFreeExtensions(&GifFile->ExtensionBlockCount,
+                      &GifFile->ExtensionBlocks);
 
-    Private = (GifFilePrivateType *) GifFile->Private;
+    Private = (GifFilePrivateType *)GifFile->Private;
 
     if (!IS_READABLE(Private)) {
         /* This file was NOT open for reading: */
-        if (ErrorCode != NULL)
+        if (ErrorCode != NULL) {
             *ErrorCode = D_GIF_ERR_NOT_READABLE;
+        }
         free((char *)GifFile->Private);
         free(GifFile);
         return GIF_ERROR;
     }
 
     if (Private->File && (fclose(Private->File) != 0)) {
-        if (ErrorCode != NULL)
+        if (ErrorCode != NULL) {
             *ErrorCode = D_GIF_ERR_CLOSE_FAILED;
+        }
         free((char *)GifFile->Private);
         free(GifFile);
         return GIF_ERROR;
@@ -739,17 +749,16 @@ DGifCloseFile(GifFileType *GifFile, int *ErrorCode)
 
     free((char *)GifFile->Private);
     free(GifFile);
-    if (ErrorCode != NULL)
+    if (ErrorCode != NULL) {
         *ErrorCode = D_GIF_SUCCEEDED;
+    }
     return GIF_OK;
 }
 
 /******************************************************************************
  Get 2 bytes (word) from the given file:
 ******************************************************************************/
-static int
-DGifGetWord(GifFileType *GifFile, GifWord *Word)
-{
+static int DGifGetWord(GifFileType *GifFile, GifWord *Word) {
     unsigned char c[2];
 
     /* coverity[check_return] */
@@ -769,9 +778,7 @@ DGifGetWord(GifFileType *GifFile, GifWord *Word)
  to DGifGetCodeNext, until NULL block is returned.
  The block should NOT be freed by the user (not dynamically allocated).
 ******************************************************************************/
-int
-DGifGetCode(GifFileType *GifFile, int *CodeSize, GifByteType **CodeBlock)
-{
+int DGifGetCode(GifFileType *GifFile, int *CodeSize, GifByteType **CodeBlock) {
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
     if (!IS_READABLE(Private)) {
@@ -790,9 +797,7 @@ DGifGetCode(GifFileType *GifFile, int *CodeSize, GifByteType **CodeBlock)
  called until NULL block is returned.
  The block should NOT be freed by the user (not dynamically allocated).
 ******************************************************************************/
-int
-DGifGetCodeNext(GifFileType *GifFile, GifByteType **CodeBlock)
-{
+int DGifGetCodeNext(GifFileType *GifFile, GifByteType **CodeBlock) {
     GifByteType Buf;
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
@@ -805,17 +810,19 @@ DGifGetCodeNext(GifFileType *GifFile, GifByteType **CodeBlock)
 
     /* coverity[lower_bounds] */
     if (Buf > 0) {
-        *CodeBlock = Private->Buf;    /* Use private unused buffer. */
-        (*CodeBlock)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */
-        /* coverity[tainted_data] */
+        *CodeBlock = Private->Buf; /* Use private unused buffer. */
+        (*CodeBlock)[0] =
+            Buf; /* Pascal strings notation (pos. 0 is len.). */
+                 /* coverity[tainted_data] */
         if (InternalRead(GifFile, &((*CodeBlock)[1]), Buf) != Buf) {
             GifFile->Error = D_GIF_ERR_READ_FAILED;
             return GIF_ERROR;
         }
     } else {
         *CodeBlock = NULL;
-        Private->Buf[0] = 0;    /* Make sure the buffer is empty! */
-        Private->PixelCount = 0;    /* And local info. indicate image read. */
+        Private->Buf[0] = 0; /* Make sure the buffer is empty! */
+        Private->PixelCount =
+            0; /* And local info. indicate image read. */
     }
 
     return GIF_OK;
@@ -824,41 +831,43 @@ DGifGetCodeNext(GifFileType *GifFile, GifByteType **CodeBlock)
 /******************************************************************************
  Setup the LZ decompression for this image:
 ******************************************************************************/
-static int
-DGifSetupDecompress(GifFileType *GifFile)
-{
+static int DGifSetupDecompress(GifFileType *GifFile) {
     int i, BitsPerPixel;
     GifByteType CodeSize;
     GifPrefixType *Prefix;
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
     /* coverity[check_return] */
-    if (InternalRead(GifFile, &CodeSize, 1) < 1) {    /* Read Code size from file. */
-        return GIF_ERROR;    /* Failed to read Code size. */
+    if (InternalRead(GifFile, &CodeSize, 1) <
+        1) { /* Read Code size from file. */
+        GifFile->Error = D_GIF_ERR_READ_FAILED;
+        return GIF_ERROR; /* Failed to read Code size. */
     }
     BitsPerPixel = CodeSize;
 
     /* this can only happen on a severely malformed GIF */
     if (BitsPerPixel > 8) {
-        GifFile->Error = D_GIF_ERR_READ_FAILED;    /* somewhat bogus error code */
-        return GIF_ERROR;    /* Failed to read Code size. */
+        GifFile->Error =
+            D_GIF_ERR_READ_FAILED; /* somewhat bogus error code */
+        return GIF_ERROR;          /* Failed to read Code size. */
     }
 
-    Private->Buf[0] = 0;    /* Input Buffer empty. */
+    Private->Buf[0] = 0; /* Input Buffer empty. */
     Private->BitsPerPixel = BitsPerPixel;
     Private->ClearCode = (1 << BitsPerPixel);
     Private->EOFCode = Private->ClearCode + 1;
     Private->RunningCode = Private->EOFCode + 1;
-    Private->RunningBits = BitsPerPixel + 1;    /* Number of bits per code. */
-    Private->MaxCode1 = 1 << Private->RunningBits;    /* Max. code + 1. */
-    Private->StackPtr = 0;    /* No pixels on the pixel stack. */
+    Private->RunningBits = BitsPerPixel + 1; /* Number of bits per code. */
+    Private->MaxCode1 = 1 << Private->RunningBits; /* Max. code + 1. */
+    Private->StackPtr = 0; /* No pixels on the pixel stack. */
     Private->LastCode = NO_SUCH_CODE;
-    Private->CrntShiftState = 0;    /* No information in CrntShiftDWord. */
+    Private->CrntShiftState = 0; /* No information in CrntShiftDWord. */
     Private->CrntShiftDWord = 0;
 
     Prefix = Private->Prefix;
-    for (i = 0; i <= LZ_MAX_CODE; i++)
+    for (i = 0; i <= LZ_MAX_CODE; i++) {
         Prefix[i] = NO_SUCH_CODE;
+    }
 
     return GIF_OK;
 }
@@ -869,14 +878,13 @@ DGifSetupDecompress(GifFileType *GifFile)
  This routine can be called few times (one per scan line, for example), in
  order the complete the whole image.
 ******************************************************************************/
-static int
-DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
-{
+static int DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line,
+                              int LineLen) {
     int i = 0;
     int j, CrntCode, EOFCode, ClearCode, CrntPrefix, LastCode, StackPtr;
     GifByteType *Stack, *Suffix;
     GifPrefixType *Prefix;
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
+    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
     StackPtr = Private->StackPtr;
     Prefix = Private->Prefix;
@@ -891,72 +899,88 @@ DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
     }
 
     if (StackPtr != 0) {
-        /* Let pop the stack off before continueing to read the GIF file: */
-        while (StackPtr != 0 && i < LineLen)
+        /* Let pop the stack off before continueing to read the GIF
+         * file: */
+        while (StackPtr != 0 && i < LineLen) {
             Line[i++] = Stack[--StackPtr];
+        }
     }
 
-    while (i < LineLen) {    /* Decode LineLen items. */
-        if (DGifDecompressInput(GifFile, &CrntCode) == GIF_ERROR)
+    while (i < LineLen) { /* Decode LineLen items. */
+        if (DGifDecompressInput(GifFile, &CrntCode) == GIF_ERROR) {
             return GIF_ERROR;
+        }
 
         if (CrntCode == EOFCode) {
-            /* Note however that usually we will not be here as we will stop
-             * decoding as soon as we got all the pixel, or EOF code will
-             * not be read at all, and DGifGetLine/Pixel clean everything.  */
+            /* Note however that usually we will not be here as we
+             * will stop decoding as soon as we got all the pixel,
+             * or EOF code will not be read at all, and
+             * DGifGetLine/Pixel clean everything.  */
             GifFile->Error = D_GIF_ERR_EOF_TOO_SOON;
             return GIF_ERROR;
         } else if (CrntCode == ClearCode) {
             /* We need to start over again: */
-            for (j = 0; j <= LZ_MAX_CODE; j++)
+            for (j = 0; j <= LZ_MAX_CODE; j++) {
                 Prefix[j] = NO_SUCH_CODE;
+            }
             Private->RunningCode = Private->EOFCode + 1;
             Private->RunningBits = Private->BitsPerPixel + 1;
             Private->MaxCode1 = 1 << Private->RunningBits;
             LastCode = Private->LastCode = NO_SUCH_CODE;
         } else {
-            /* Its regular code - if in pixel range simply add it to output
-             * stream, otherwise trace to codes linked list until the prefix
-             * is in pixel range: */
+            /* Its regular code - if in pixel range simply add it to
+             * output stream, otherwise trace to codes linked list
+             * until the prefix is in pixel range: */
             if (CrntCode < ClearCode) {
-                /* This is simple - its pixel scalar, so add it to output: */
+                /* This is simple - its pixel scalar, so add it
+                 * to output: */
                 Line[i++] = CrntCode;
             } else {
-                /* Its a code to needed to be traced: trace the linked list
-                 * until the prefix is a pixel, while pushing the suffix
-                 * pixels on our stack. If we done, pop the stack in reverse
-                 * (thats what stack is good for!) order to output.  */
+                /* Its a code to needed to be traced: trace the
+                 * linked list until the prefix is a pixel,
+                 * while pushing the suffix pixels on our stack.
+                 * If we done, pop the stack in reverse (thats
+                 * what stack is good for!) order to output.  */
                 if (Prefix[CrntCode] == NO_SUCH_CODE) {
                     CrntPrefix = LastCode;
 
-                    /* Only allowed if CrntCode is exactly the running code:
-                     * In that case CrntCode = XXXCode, CrntCode or the
-                     * prefix code is last code and the suffix char is
-                     * exactly the prefix of last code! */
-                    if (CrntCode == Private->RunningCode - 2) {
-                        Suffix[Private->RunningCode - 2] =
-                           Stack[StackPtr++] = DGifGetPrefixChar(Prefix,
-                                                                 LastCode,
-                                                                 ClearCode);
+                    /* Only allowed if CrntCode is exactly
+                     * the running code: In that case
+                     * CrntCode = XXXCode, CrntCode or the
+                     * prefix code is last code and the
+                     * suffix char is exactly the prefix of
+                     * last code! */
+                    if (CrntCode ==
+                        Private->RunningCode - 2) {
+                        Suffix[Private->RunningCode -
+                               2] = Stack[StackPtr++] =
+                            DGifGetPrefixChar(
+                                Prefix, LastCode,
+                                ClearCode);
                     } else {
-                        Suffix[Private->RunningCode - 2] =
-                           Stack[StackPtr++] = DGifGetPrefixChar(Prefix,
-                                                                 CrntCode,
-                                                                 ClearCode);
+                        Suffix[Private->RunningCode -
+                               2] = Stack[StackPtr++] =
+                            DGifGetPrefixChar(
+                                Prefix, CrntCode,
+                                ClearCode);
                     }
-                } else
+                } else {
                     CrntPrefix = CrntCode;
+                }
 
-                /* Now (if image is O.K.) we should not get a NO_SUCH_CODE
-                 * during the trace. As we might loop forever, in case of
-                 * defective image, we use StackPtr as loop counter and stop
-                 * before overflowing Stack[]. */
+                /* Now (if image is O.K.) we should not get a
+                 * NO_SUCH_CODE during the trace. As we might
+                 * loop forever, in case of defective image, we
+                 * use StackPtr as loop counter and stop before
+                 * overflowing Stack[]. */
                 while (StackPtr < LZ_MAX_CODE &&
-                       CrntPrefix > ClearCode && CrntPrefix <= LZ_MAX_CODE) {
+                       CrntPrefix > ClearCode &&
+                       CrntPrefix <= LZ_MAX_CODE) {
                     Stack[StackPtr++] = Suffix[CrntPrefix];
                     CrntPrefix = Prefix[CrntPrefix];
                 }
-                if (StackPtr >= LZ_MAX_CODE || CrntPrefix > LZ_MAX_CODE) {
+                if (StackPtr >= LZ_MAX_CODE ||
+                    CrntPrefix > LZ_MAX_CODE) {
                     GifFile->Error = D_GIF_ERR_IMAGE_DEFECT;
                     return GIF_ERROR;
                 }
@@ -964,22 +988,29 @@ DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
                 Stack[StackPtr++] = CrntPrefix;
 
                 /* Now lets pop all the stack into output: */
-                while (StackPtr != 0 && i < LineLen)
+                while (StackPtr != 0 && i < LineLen) {
                     Line[i++] = Stack[--StackPtr];
+                }
             }
-            if (LastCode != NO_SUCH_CODE && Private->RunningCode - 2 < (LZ_MAX_CODE+1) && Prefix[Private->RunningCode - 2] == NO_SUCH_CODE) {
+            if (LastCode != NO_SUCH_CODE &&
+                Private->RunningCode - 2 < (LZ_MAX_CODE + 1) &&
+                Prefix[Private->RunningCode - 2] == NO_SUCH_CODE) {
                 Prefix[Private->RunningCode - 2] = LastCode;
 
                 if (CrntCode == Private->RunningCode - 2) {
-                    /* Only allowed if CrntCode is exactly the running code:
-                     * In that case CrntCode = XXXCode, CrntCode or the
-                     * prefix code is last code and the suffix char is
-                     * exactly the prefix of last code! */
+                    /* Only allowed if CrntCode is exactly
+                     * the running code: In that case
+                     * CrntCode = XXXCode, CrntCode or the
+                     * prefix code is last code and the
+                     * suffix char is exactly the prefix of
+                     * last code! */
                     Suffix[Private->RunningCode - 2] =
-                       DGifGetPrefixChar(Prefix, LastCode, ClearCode);
+                        DGifGetPrefixChar(Prefix, LastCode,
+                                          ClearCode);
                 } else {
                     Suffix[Private->RunningCode - 2] =
-                       DGifGetPrefixChar(Prefix, CrntCode, ClearCode);
+                        DGifGetPrefixChar(Prefix, CrntCode,
+                                          ClearCode);
                 }
             }
             LastCode = CrntCode;
@@ -998,9 +1029,8 @@ DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
  If image is defective, we might loop here forever, so we limit the loops to
  the maximum possible if image O.k. - LZ_MAX_CODE times.
 ******************************************************************************/
-static int
-DGifGetPrefixChar(GifPrefixType *Prefix, int Code, int ClearCode)
-{
+static int DGifGetPrefixChar(const GifPrefixType *Prefix, int Code,
+                             int ClearCode) {
     int i = 0;
 
     while (Code > ClearCode && i++ <= LZ_MAX_CODE) {
@@ -1016,9 +1046,7 @@ DGifGetPrefixChar(GifPrefixType *Prefix, int Code, int ClearCode)
  Interface for accessing the LZ codes directly. Set Code to the real code
  (12bits), or to -1 if EOF code is returned.
 ******************************************************************************/
-int
-DGifGetLZCodes(GifFileType *GifFile, int *Code)
-{
+int DGifGetLZCodes(GifFileType *GifFile, int *Code) {
     GifByteType *CodeBlock;
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
@@ -1028,15 +1056,18 @@ DGifGetLZCodes(GifFileType *GifFile, int *Code)
         return GIF_ERROR;
     }
 
-    if (DGifDecompressInput(GifFile, Code) == GIF_ERROR)
+    if (DGifDecompressInput(GifFile, Code) == GIF_ERROR) {
         return GIF_ERROR;
+    }
 
     if (*Code == Private->EOFCode) {
-        /* Skip rest of codes (hopefully only NULL terminating block): */
+        /* Skip rest of codes (hopefully only NULL terminating block):
+         */
         do {
-            if (DGifGetCodeNext(GifFile, &CodeBlock) == GIF_ERROR)
+            if (DGifGetCodeNext(GifFile, &CodeBlock) == GIF_ERROR) {
                 return GIF_ERROR;
-        } while (CodeBlock != NULL) ;
+            }
+        } while (CodeBlock != NULL);
 
         *Code = -1;
     } else if (*Code == Private->ClearCode) {
@@ -1055,15 +1086,10 @@ DGifGetLZCodes(GifFileType *GifFile, int *Code)
  8 bits (bytes) packets, into the real codes.
  Returns GIF_OK if read successfully.
 ******************************************************************************/
-static int
-DGifDecompressInput(GifFileType *GifFile, int *Code)
-{
+static int DGifDecompressInput(GifFileType *GifFile, int *Code) {
     static const unsigned short CodeMasks[] = {
-        0x0000, 0x0001, 0x0003, 0x0007,
-        0x000f, 0x001f, 0x003f, 0x007f,
-        0x00ff, 0x01ff, 0x03ff, 0x07ff,
-        0x0fff
-    };
+        0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f,
+        0x007f, 0x00ff, 0x01ff, 0x03ff, 0x07ff, 0x0fff};
 
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
@@ -1077,11 +1103,12 @@ DGifDecompressInput(GifFileType *GifFile, int *Code)
 
     while (Private->CrntShiftState < Private->RunningBits) {
         /* Needs to get more bytes from input stream for next code: */
-        if (DGifBufferedInput(GifFile, Private->Buf, &NextByte) == GIF_ERROR) {
+        if (DGifBufferedInput(GifFile, Private->Buf, &NextByte) ==
+            GIF_ERROR) {
             return GIF_ERROR;
         }
-        Private->CrntShiftDWord |=
-            ((unsigned long)NextByte) << Private->CrntShiftState;
+        Private->CrntShiftDWord |= ((unsigned long)NextByte)
+                                   << Private->CrntShiftState;
         Private->CrntShiftState += 8;
     }
     *Code = Private->CrntShiftDWord & CodeMasks[Private->RunningBits];
@@ -1109,9 +1136,8 @@ DGifDecompressInput(GifFileType *GifFile, int *Code)
  The routine returns the next byte from its internal buffer (or read next
  block in if buffer empty) and returns GIF_OK if succesful.
 ******************************************************************************/
-static int
-DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf, GifByteType *NextByte)
-{
+static int DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf,
+                             GifByteType *NextByte) {
     if (Buf[0] == 0) {
         /* Needs to read the next buffer - this one is empty: */
         /* coverity[check_return] */
@@ -1120,8 +1146,8 @@ DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf, GifByteType *NextByte)
             return GIF_ERROR;
         }
         /* There shouldn't be any empty data blocks here as the LZW spec
-         * says the LZW termination code should come first.  Therefore we
-         * shouldn't be inside this routine at that point.
+         * says the LZW termination code should come first.  Therefore
+         * we shouldn't be inside this routine at that point.
          */
         if (Buf[0] == 0) {
             GifFile->Error = D_GIF_ERR_IMAGE_DEFECT;
@@ -1132,7 +1158,7 @@ DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf, GifByteType *NextByte)
             return GIF_ERROR;
         }
         *NextByte = Buf[1];
-        Buf[1] = 2;    /* We use now the second place as last char read! */
+        Buf[1] = 2; /* We use now the second place as last char read! */
         Buf[0]--;
     } else {
         *NextByte = Buf[Buf[1]++];
@@ -1142,14 +1168,32 @@ DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf, GifByteType *NextByte)
     return GIF_OK;
 }
 
+/******************************************************************************
+ This routine is called in case of error during parsing image. We need to
+ decrease image counter and reallocate memory for saved images. Not decreasing
+ ImageCount may lead to null pointer dereference, because the last element in
+ SavedImages may point to the spoilt image and null pointer buffers.
+*******************************************************************************/
+void DGifDecreaseImageCounter(GifFileType *GifFile) {
+    GifFile->ImageCount--;
+    if (GifFile->SavedImages[GifFile->ImageCount].RasterBits != NULL) {
+        free(GifFile->SavedImages[GifFile->ImageCount].RasterBits);
+    }
+
+    // Realloc array according to the new image counter.
+    SavedImage *correct_saved_images = (SavedImage *)reallocarray(
+        GifFile->SavedImages, GifFile->ImageCount, sizeof(SavedImage));
+    if (correct_saved_images != NULL) {
+        GifFile->SavedImages = correct_saved_images;
+    }
+}
+
 /******************************************************************************
  This routine reads an entire GIF into core, hanging all its state info off
  the GifFileType pointer.  Call DGifOpenFileName() or DGifOpenFileHandle()
  first to initialize I/O.  Its inverse is EGifSpew().
 *******************************************************************************/
-int
-DGifSlurp(GifFileType *GifFile)
-{
+int DGifSlurp(GifFileType *GifFile) {
     size_t ImageSize;
     GifRecordType RecordType;
     SavedImage *sp;
@@ -1160,103 +1204,130 @@ DGifSlurp(GifFileType *GifFile)
     GifFile->ExtensionBlockCount = 0;
 
     do {
-        if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR)
+        if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR) {
             return (GIF_ERROR);
+        }
 
         switch (RecordType) {
-          case IMAGE_DESC_RECORD_TYPE:
-              if (DGifGetImageDesc(GifFile) == GIF_ERROR)
-                  return (GIF_ERROR);
-
-              sp = &GifFile->SavedImages[GifFile->ImageCount - 1];
-              /* Allocate memory for the image */
-              if (sp->ImageDesc.Width <= 0 || sp->ImageDesc.Height <= 0 ||
-                      sp->ImageDesc.Width > (INT_MAX / sp->ImageDesc.Height)) {
-                  return GIF_ERROR;
-              }
-              ImageSize = sp->ImageDesc.Width * sp->ImageDesc.Height;
-
-              if (ImageSize > (SIZE_MAX / sizeof(GifPixelType))) {
-                  return GIF_ERROR;
-              }
-              sp->RasterBits = (unsigned char *)reallocarray(NULL, ImageSize,
-                      sizeof(GifPixelType));
-
-              if (sp->RasterBits == NULL) {
-                  return GIF_ERROR;
-              }
-
-              if (sp->ImageDesc.Interlace) {
-                  int i, j;
-                   /*
-                    * The way an interlaced image should be read -
-                    * offsets and jumps...
-                    */
-                  int InterlacedOffset[] = { 0, 4, 2, 1 };
-                  int InterlacedJumps[] = { 8, 8, 4, 2 };
-                  /* Need to perform 4 passes on the image */
-                  for (i = 0; i < 4; i++)
-                      for (j = InterlacedOffset[i];
-                       j < sp->ImageDesc.Height;
-                       j += InterlacedJumps[i]) {
-                      if (DGifGetLine(GifFile,
-                              sp->RasterBits+j*sp->ImageDesc.Width,
-                              sp->ImageDesc.Width) == GIF_ERROR)
-                          return GIF_ERROR;
-                      }
-              }
-              else {
-                  if (DGifGetLine(GifFile,sp->RasterBits,ImageSize)==GIF_ERROR)
-                      return (GIF_ERROR);
-              }
-
-              if (GifFile->ExtensionBlocks) {
-                  sp->ExtensionBlocks = GifFile->ExtensionBlocks;
-                  sp->ExtensionBlockCount = GifFile->ExtensionBlockCount;
-
-                  GifFile->ExtensionBlocks = NULL;
-                  GifFile->ExtensionBlockCount = 0;
-              }
-              break;
-
-          case EXTENSION_RECORD_TYPE:
-              if (DGifGetExtension(GifFile,&ExtFunction,&ExtData) == GIF_ERROR)
-                  return (GIF_ERROR);
-              /* Create an extension block with our data */
-              if (ExtData != NULL) {
-                  if (GifAddExtensionBlock(&GifFile->ExtensionBlockCount,
-                               &GifFile->ExtensionBlocks,
-                               ExtFunction, ExtData[0], &ExtData[1])
-                      == GIF_ERROR)
-                      return (GIF_ERROR);
-              }
-              for (;;) {
-                  if (DGifGetExtensionNext(GifFile, &ExtData) == GIF_ERROR)
-                      return (GIF_ERROR);
-                  if (ExtData == NULL)
-                      break;
-                  /* Continue the extension block */
-                  if (ExtData != NULL)
-                      if (GifAddExtensionBlock(&GifFile->ExtensionBlockCount,
-                                   &GifFile->ExtensionBlocks,
-                                   CONTINUE_EXT_FUNC_CODE,
-                                   ExtData[0], &ExtData[1]) == GIF_ERROR)
-                              return (GIF_ERROR);
-              }
-              break;
-
-          case TERMINATE_RECORD_TYPE:
-              break;
-
-          default:    /* Should be trapped by DGifGetRecordType */
-              break;
+        case IMAGE_DESC_RECORD_TYPE:
+            if (DGifGetImageDesc(GifFile) == GIF_ERROR) {
+                return (GIF_ERROR);
+            }
+
+            sp = &GifFile->SavedImages[GifFile->ImageCount - 1];
+            /* Allocate memory for the image */
+            if (sp->ImageDesc.Width <= 0 ||
+                sp->ImageDesc.Height <= 0 ||
+                sp->ImageDesc.Width >
+                    (INT_MAX / sp->ImageDesc.Height)) {
+                DGifDecreaseImageCounter(GifFile);
+                return GIF_ERROR;
+            }
+            ImageSize = sp->ImageDesc.Width * sp->ImageDesc.Height;
+
+            if (ImageSize > (SIZE_MAX / sizeof(GifPixelType))) {
+                DGifDecreaseImageCounter(GifFile);
+                return GIF_ERROR;
+            }
+            sp->RasterBits = (unsigned char *)reallocarray(
+                NULL, ImageSize, sizeof(GifPixelType));
+
+            if (sp->RasterBits == NULL) {
+                DGifDecreaseImageCounter(GifFile);
+                return GIF_ERROR;
+            }
+
+            if (sp->ImageDesc.Interlace) {
+                int i, j;
+                /*
+                 * The way an interlaced image should be read -
+                 * offsets and jumps...
+                 */
+                static const int InterlacedOffset[] = {0, 4, 2,
+                                                       1};
+                static const int InterlacedJumps[] = {8, 8, 4,
+                                                      2};
+                /* Need to perform 4 passes on the image */
+                for (i = 0; i < 4; i++) {
+                    for (j = InterlacedOffset[i];
+                         j < sp->ImageDesc.Height;
+                         j += InterlacedJumps[i]) {
+                        if (DGifGetLine(
+                                GifFile,
+                                sp->RasterBits +
+                                    j * sp->ImageDesc
+                                            .Width,
+                                sp->ImageDesc.Width) ==
+                            GIF_ERROR) {
+                            DGifDecreaseImageCounter(
+                                GifFile);
+                            return GIF_ERROR;
+                        }
+                    }
+                }
+            } else {
+                if (DGifGetLine(GifFile, sp->RasterBits,
+                                ImageSize) == GIF_ERROR) {
+                    DGifDecreaseImageCounter(GifFile);
+                    return GIF_ERROR;
+                }
+            }
+
+            if (GifFile->ExtensionBlocks) {
+                sp->ExtensionBlocks = GifFile->ExtensionBlocks;
+                sp->ExtensionBlockCount =
+                    GifFile->ExtensionBlockCount;
+
+                GifFile->ExtensionBlocks = NULL;
+                GifFile->ExtensionBlockCount = 0;
+            }
+            break;
+
+        case EXTENSION_RECORD_TYPE:
+            if (DGifGetExtension(GifFile, &ExtFunction, &ExtData) ==
+                GIF_ERROR) {
+                return (GIF_ERROR);
+            }
+            /* Create an extension block with our data */
+            if (ExtData != NULL) {
+                if (GifAddExtensionBlock(
+                        &GifFile->ExtensionBlockCount,
+                        &GifFile->ExtensionBlocks, ExtFunction,
+                        ExtData[0], &ExtData[1]) == GIF_ERROR) {
+                    return (GIF_ERROR);
+                }
+            }
+            for (;;) {
+                if (DGifGetExtensionNext(GifFile, &ExtData) ==
+                    GIF_ERROR) {
+                    return (GIF_ERROR);
+                }
+                if (ExtData == NULL) {
+                    break;
+                }
+                /* Continue the extension block */
+                if (GifAddExtensionBlock(
+                        &GifFile->ExtensionBlockCount,
+                        &GifFile->ExtensionBlocks,
+                        CONTINUE_EXT_FUNC_CODE, ExtData[0],
+                        &ExtData[1]) == GIF_ERROR) {
+                    return (GIF_ERROR);
+                }
+            }
+            break;
+
+        case TERMINATE_RECORD_TYPE:
+            break;
+
+        default: /* Should be trapped by DGifGetRecordType */
+            break;
         }
     } while (RecordType != TERMINATE_RECORD_TYPE);
 
     /* Sanity check for corrupted file */
     if (GifFile->ImageCount == 0) {
         GifFile->Error = D_GIF_ERR_NO_IMAG_DSCR;
-        return(GIF_ERROR);
+        return (GIF_ERROR);
     }
 
     return (GIF_OK);
diff --git a/jdk/src/share/native/sun/awt/giflib/gif_err.c b/jdk/src/share/native/sun/awt/giflib/gif_err.c
index db08838eff..3b6785f7c6 100644
--- a/jdk/src/share/native/sun/awt/giflib/gif_err.c
+++ b/jdk/src/share/native/sun/awt/giflib/gif_err.c
@@ -38,82 +38,80 @@ SPDX-License-Identifier: MIT
 /*****************************************************************************
  Return a string description of  the last GIF error
 *****************************************************************************/
-const char *
-GifErrorString(int ErrorCode)
-{
+const char *GifErrorString(int ErrorCode) {
     const char *Err;
 
     switch (ErrorCode) {
-      case E_GIF_ERR_OPEN_FAILED:
+    case E_GIF_ERR_OPEN_FAILED:
         Err = "Failed to open given file";
         break;
-      case E_GIF_ERR_WRITE_FAILED:
+    case E_GIF_ERR_WRITE_FAILED:
         Err = "Failed to write to given file";
         break;
-      case E_GIF_ERR_HAS_SCRN_DSCR:
+    case E_GIF_ERR_HAS_SCRN_DSCR:
         Err = "Screen descriptor has already been set";
         break;
-      case E_GIF_ERR_HAS_IMAG_DSCR:
+    case E_GIF_ERR_HAS_IMAG_DSCR:
         Err = "Image descriptor is still active";
         break;
-      case E_GIF_ERR_NO_COLOR_MAP:
+    case E_GIF_ERR_NO_COLOR_MAP:
         Err = "Neither global nor local color map";
         break;
-      case E_GIF_ERR_DATA_TOO_BIG:
+    case E_GIF_ERR_DATA_TOO_BIG:
         Err = "Number of pixels bigger than width * height";
         break;
-      case E_GIF_ERR_NOT_ENOUGH_MEM:
+    case E_GIF_ERR_NOT_ENOUGH_MEM:
         Err = "Failed to allocate required memory";
         break;
-      case E_GIF_ERR_DISK_IS_FULL:
+    case E_GIF_ERR_DISK_IS_FULL:
         Err = "Write failed (disk full?)";
         break;
-      case E_GIF_ERR_CLOSE_FAILED:
+    case E_GIF_ERR_CLOSE_FAILED:
         Err = "Failed to close given file";
         break;
-      case E_GIF_ERR_NOT_WRITEABLE:
+    case E_GIF_ERR_NOT_WRITEABLE:
         Err = "Given file was not opened for write";
         break;
-      case D_GIF_ERR_OPEN_FAILED:
+    case D_GIF_ERR_OPEN_FAILED:
         Err = "Failed to open given file";
         break;
-      case D_GIF_ERR_READ_FAILED:
+    case D_GIF_ERR_READ_FAILED:
         Err = "Failed to read from given file";
         break;
-      case D_GIF_ERR_NOT_GIF_FILE:
+    case D_GIF_ERR_NOT_GIF_FILE:
         Err = "Data is not in GIF format";
         break;
-      case D_GIF_ERR_NO_SCRN_DSCR:
+    case D_GIF_ERR_NO_SCRN_DSCR:
         Err = "No screen descriptor detected";
         break;
-      case D_GIF_ERR_NO_IMAG_DSCR:
+    case D_GIF_ERR_NO_IMAG_DSCR:
         Err = "No Image Descriptor detected";
         break;
-      case D_GIF_ERR_NO_COLOR_MAP:
+    case D_GIF_ERR_NO_COLOR_MAP:
         Err = "Neither global nor local color map";
         break;
-      case D_GIF_ERR_WRONG_RECORD:
+    case D_GIF_ERR_WRONG_RECORD:
         Err = "Wrong record type detected";
         break;
-      case D_GIF_ERR_DATA_TOO_BIG:
+    case D_GIF_ERR_DATA_TOO_BIG:
         Err = "Number of pixels bigger than width * height";
         break;
-      case D_GIF_ERR_NOT_ENOUGH_MEM:
+    case D_GIF_ERR_NOT_ENOUGH_MEM:
         Err = "Failed to allocate required memory";
         break;
-      case D_GIF_ERR_CLOSE_FAILED:
+    case D_GIF_ERR_CLOSE_FAILED:
         Err = "Failed to close given file";
         break;
-      case D_GIF_ERR_NOT_READABLE:
+    case D_GIF_ERR_NOT_READABLE:
         Err = "Given file was not opened for read";
         break;
-      case D_GIF_ERR_IMAGE_DEFECT:
+    case D_GIF_ERR_IMAGE_DEFECT:
         Err = "Image is defective, decoding aborted";
         break;
-      case D_GIF_ERR_EOF_TOO_SOON:
+    case D_GIF_ERR_EOF_TOO_SOON:
         Err = "Image EOF detected before image complete";
         break;
-      default:
+    default:
         Err = NULL;
         break;
     }
diff --git a/jdk/src/share/native/sun/awt/giflib/gif_hash.h b/jdk/src/share/native/sun/awt/giflib/gif_hash.h
index 6cabd0866e..bd00af6416 100644
--- a/jdk/src/share/native/sun/awt/giflib/gif_hash.h
+++ b/jdk/src/share/native/sun/awt/giflib/gif_hash.h
@@ -33,27 +33,25 @@ SPDX-License-Identifier: MIT
 #ifndef _GIF_HASH_H_
 #define _GIF_HASH_H_
 
-/** Begin JDK modifications to support building on Windows **/
 #ifndef _WIN32
 #include <unistd.h>
-#endif
-/** End JDK modifications to support building on Windows **/
+#endif /* _WIN32 */
 #include <stdint.h>
 
-#define HT_SIZE         8192    /* 12bits = 4096 or twice as big! */
-#define HT_KEY_MASK     0x1FFF  /* 13bits keys */
-#define HT_KEY_NUM_BITS 13      /* 13bits keys */
-#define HT_MAX_KEY      8191    /* 13bits - 1, maximal code possible */
-#define HT_MAX_CODE     4095    /* Biggest code possible in 12 bits. */
+#define HT_SIZE 8192       /* 12bits = 4096 or twice as big! */
+#define HT_KEY_MASK 0x1FFF /* 13bits keys */
+#define HT_KEY_NUM_BITS 13 /* 13bits keys */
+#define HT_MAX_KEY 8191    /* 13bits - 1, maximal code possible */
+#define HT_MAX_CODE 4095   /* Biggest code possible in 12 bits. */
 
 /* The 32 bits of the long are divided into two parts for the key & code:   */
 /* 1. The code is 12 bits as our compression algorithm is limited to 12bits */
-/* 2. The key is 12 bits Prefix code + 8 bit new char or 20 bits.           */
+/* 2. The key is 12 bits Prefix code + 8 bit new char or 20 bits.        */
 /* The key is the upper 20 bits.  The code is the lower 12. */
-#define HT_GET_KEY(l)    (l >> 12)
-#define HT_GET_CODE(l)   (l & 0x0FFF)
-#define HT_PUT_KEY(l)    (l << 12)
-#define HT_PUT_CODE(l)   (l & 0x0FFF)
+#define HT_GET_KEY(l) (l >> 12)
+#define HT_GET_CODE(l) (l & 0x0FFF)
+#define HT_PUT_KEY(l) (l << 12)
+#define HT_PUT_CODE(l) (l & 0x0FFF)
 
 typedef struct GifHashTableType {
     uint32_t HTable[HT_SIZE];
diff --git a/jdk/src/share/native/sun/awt/giflib/gif_lib.h b/jdk/src/share/native/sun/awt/giflib/gif_lib.h
index f739b36adf..716dc7e8ba 100644
--- a/jdk/src/share/native/sun/awt/giflib/gif_lib.h
+++ b/jdk/src/share/native/sun/awt/giflib/gif_lib.h
@@ -39,27 +39,30 @@ extern "C" {
 
 #define GIFLIB_MAJOR 5
 #define GIFLIB_MINOR 2
-#define GIFLIB_RELEASE 1
+#define GIFLIB_RELEASE 2
 
-#define GIF_ERROR   0
-#define GIF_OK      1
+#define GIF_ERROR 0
+#define GIF_OK 1
 
 #include <stddef.h>
 /** Begin JDK modifications to support building using old compilers**/
-//#include <stdbool.h>
+#ifndef _WIN32
+#include <stdbool.h>
+#else
 #ifdef bool
 #undef bool
 #endif
 typedef int bool;
 #define false 0
 #define true 1
+#endif
 /** End JDK modifications to support building using old compilers**/
 
-#define GIF_STAMP "GIFVER"          /* First chars in file - GIF stamp.  */
+#define GIF_STAMP "GIFVER" /* First chars in file - GIF stamp.  */
 #define GIF_STAMP_LEN sizeof(GIF_STAMP) - 1
-#define GIF_VERSION_POS 3           /* Version first character in stamp. */
-#define GIF87_STAMP "GIF87a"        /* First chars in file - GIF stamp.  */
-#define GIF89_STAMP "GIF89a"        /* First chars in file - GIF stamp.  */
+#define GIF_VERSION_POS 3    /* Version first character in stamp. */
+#define GIF87_STAMP "GIF87a" /* First chars in file - GIF stamp.  */
+#define GIF89_STAMP "GIF89a" /* First chars in file - GIF stamp.  */
 
 typedef unsigned char GifPixelType;
 typedef unsigned char *GifRowType;
@@ -75,24 +78,24 @@ typedef struct ColorMapObject {
     int ColorCount;
     int BitsPerPixel;
     bool SortFlag;
-    GifColorType *Colors;    /* on malloc(3) heap */
+    GifColorType *Colors; /* on malloc(3) heap */
 } ColorMapObject;
 
 typedef struct GifImageDesc {
-    GifWord Left, Top, Width, Height;   /* Current image dimensions. */
-    bool Interlace;                     /* Sequential/Interlaced lines. */
-    ColorMapObject *ColorMap;           /* The local color map */
+    GifWord Left, Top, Width, Height; /* Current image dimensions. */
+    bool Interlace;                   /* Sequential/Interlaced lines. */
+    ColorMapObject *ColorMap;         /* The local color map */
 } GifImageDesc;
 
 typedef struct ExtensionBlock {
     int ByteCount;
-    GifByteType *Bytes; /* on malloc(3) heap */
-    int Function;       /* The block function code */
-#define CONTINUE_EXT_FUNC_CODE    0x00    /* continuation subblock */
-#define COMMENT_EXT_FUNC_CODE     0xfe    /* comment */
-#define GRAPHICS_EXT_FUNC_CODE    0xf9    /* graphics control (GIF89) */
-#define PLAINTEXT_EXT_FUNC_CODE   0x01    /* plaintext */
-#define APPLICATION_EXT_FUNC_CODE 0xff    /* application block (GIF89) */
+    GifByteType *Bytes;            /* on malloc(3) heap */
+    int Function;                  /* The block function code */
+#define CONTINUE_EXT_FUNC_CODE 0x00    /* continuation subblock */
+#define COMMENT_EXT_FUNC_CODE 0xfe     /* comment */
+#define GRAPHICS_EXT_FUNC_CODE 0xf9    /* graphics control (GIF89) */
+#define PLAINTEXT_EXT_FUNC_CODE 0x01   /* plaintext */
+#define APPLICATION_EXT_FUNC_CODE 0xff /* application block (GIF89) */
 } ExtensionBlock;
 
 typedef struct SavedImage {
@@ -103,22 +106,22 @@ typedef struct SavedImage {
 } SavedImage;
 
 typedef struct GifFileType {
-    GifWord SWidth, SHeight;         /* Size of virtual canvas */
-    GifWord SColorResolution;        /* How many colors can we generate? */
-    GifWord SBackGroundColor;        /* Background color for virtual canvas */
-    GifByteType AspectByte;          /* Used to compute pixel aspect ratio */
-    ColorMapObject *SColorMap;       /* Global colormap, NULL if nonexistent. */
-    int ImageCount;                  /* Number of current image (both APIs) */
-    GifImageDesc Image;              /* Current image (low-level API) */
-    SavedImage *SavedImages;         /* Image sequence (high-level API) */
-    int ExtensionBlockCount;         /* Count extensions past last image */
+    GifWord SWidth, SHeight;   /* Size of virtual canvas */
+    GifWord SColorResolution;  /* How many colors can we generate? */
+    GifWord SBackGroundColor;  /* Background color for virtual canvas */
+    GifByteType AspectByte;    /* Used to compute pixel aspect ratio */
+    ColorMapObject *SColorMap; /* Global colormap, NULL if nonexistent. */
+    int ImageCount;            /* Number of current image (both APIs) */
+    GifImageDesc Image;        /* Current image (low-level API) */
+    SavedImage *SavedImages;   /* Image sequence (high-level API) */
+    int ExtensionBlockCount;   /* Count extensions past last image */
     ExtensionBlock *ExtensionBlocks; /* Extensions past last image */
     int Error;                       /* Last error condition reported */
     void *UserData;                  /* hook to attach user data (TVT) */
     void *Private;                   /* Don't mess with this! */
 } GifFileType;
 
-#define GIF_ASPECT_RATIO(n)    ((n)+15.0/64.0)
+#define GIF_ASPECT_RATIO(n) ((n) + 15.0 / 64.0)
 
 typedef enum {
     UNDEFINED_RECORD_TYPE,
@@ -129,12 +132,12 @@ typedef enum {
 } GifRecordType;
 
 /* func type to read gif data from arbitrary sources (TVT) */
-typedef int (*InputFunc) (GifFileType *, GifByteType *, int);
+typedef int (*InputFunc)(GifFileType *, GifByteType *, int);
 
 /* func type to write gif data to arbitrary targets.
  * Returns count of bytes written. (MRB)
  */
-typedef int (*OutputFunc) (GifFileType *, const GifByteType *, int);
+typedef int (*OutputFunc)(GifFileType *, const GifByteType *, int);
 
 /******************************************************************************
  GIF89 structures
@@ -142,14 +145,14 @@ typedef int (*OutputFunc) (GifFileType *, const GifByteType *, int);
 
 typedef struct GraphicsControlBlock {
     int DisposalMode;
-#define DISPOSAL_UNSPECIFIED      0       /* No disposal specified. */
-#define DISPOSE_DO_NOT            1       /* Leave image in place */
-#define DISPOSE_BACKGROUND        2       /* Set area too background color */
-#define DISPOSE_PREVIOUS          3       /* Restore to previous content */
-    bool UserInputFlag;      /* User confirmation required before disposal */
-    int DelayTime;           /* pre-display delay in 0.01sec units */
-    int TransparentColor;    /* Palette index for transparency, -1 if none */
-#define NO_TRANSPARENT_COLOR    -1
+#define DISPOSAL_UNSPECIFIED 0 /* No disposal specified. */
+#define DISPOSE_DO_NOT 1       /* Leave image in place */
+#define DISPOSE_BACKGROUND 2   /* Set area too background color */
+#define DISPOSE_PREVIOUS 3     /* Restore to previous content */
+    bool UserInputFlag;    /* User confirmation required before disposal */
+    int DelayTime;         /* pre-display delay in 0.01sec units */
+    int TransparentColor;  /* Palette index for transparency, -1 if none */
+#define NO_TRANSPARENT_COLOR -1
 } GraphicsControlBlock;
 
 /******************************************************************************
@@ -161,49 +164,44 @@ GifFileType *EGifOpenFileName(const char *GifFileName,
                               const bool GifTestExistence, int *Error);
 GifFileType *EGifOpenFileHandle(const int GifFileHandle, int *Error);
 GifFileType *EGifOpen(void *userPtr, OutputFunc writeFunc, int *Error);
-int EGifSpew(GifFileType * GifFile);
+int EGifSpew(GifFileType *GifFile);
 const char *EGifGetGifVersion(GifFileType *GifFile); /* new in 5.x */
 int EGifCloseFile(GifFileType *GifFile, int *ErrorCode);
 
-#define E_GIF_SUCCEEDED          0
-#define E_GIF_ERR_OPEN_FAILED    1    /* And EGif possible errors. */
-#define E_GIF_ERR_WRITE_FAILED   2
-#define E_GIF_ERR_HAS_SCRN_DSCR  3
-#define E_GIF_ERR_HAS_IMAG_DSCR  4
-#define E_GIF_ERR_NO_COLOR_MAP   5
-#define E_GIF_ERR_DATA_TOO_BIG   6
+#define E_GIF_SUCCEEDED 0
+#define E_GIF_ERR_OPEN_FAILED 1 /* And EGif possible errors. */
+#define E_GIF_ERR_WRITE_FAILED 2
+#define E_GIF_ERR_HAS_SCRN_DSCR 3
+#define E_GIF_ERR_HAS_IMAG_DSCR 4
+#define E_GIF_ERR_NO_COLOR_MAP 5
+#define E_GIF_ERR_DATA_TOO_BIG 6
 #define E_GIF_ERR_NOT_ENOUGH_MEM 7
-#define E_GIF_ERR_DISK_IS_FULL   8
-#define E_GIF_ERR_CLOSE_FAILED   9
-#define E_GIF_ERR_NOT_WRITEABLE  10
+#define E_GIF_ERR_DISK_IS_FULL 8
+#define E_GIF_ERR_CLOSE_FAILED 9
+#define E_GIF_ERR_NOT_WRITEABLE 10
 
 /* These are legacy.  You probably do not want to call them directly */
-int EGifPutScreenDesc(GifFileType *GifFile,
-                      const int GifWidth, const int GifHeight,
-                      const int GifColorRes,
+int EGifPutScreenDesc(GifFileType *GifFile, const int GifWidth,
+                      const int GifHeight, const int GifColorRes,
                       const int GifBackGround,
                       const ColorMapObject *GifColorMap);
-int EGifPutImageDesc(GifFileType *GifFile,
-                     const int GifLeft, const int GifTop,
+int EGifPutImageDesc(GifFileType *GifFile, const int GifLeft, const int GifTop,
                      const int GifWidth, const int GifHeight,
                      const bool GifInterlace,
                      const ColorMapObject *GifColorMap);
 void EGifSetGifVersion(GifFileType *GifFile, const bool gif89);
-int EGifPutLine(GifFileType *GifFile, GifPixelType *GifLine,
-                int GifLineLen);
+int EGifPutLine(GifFileType *GifFile, GifPixelType *GifLine, int GifLineLen);
 int EGifPutPixel(GifFileType *GifFile, const GifPixelType GifPixel);
 int EGifPutComment(GifFileType *GifFile, const char *GifComment);
 int EGifPutExtensionLeader(GifFileType *GifFile, const int GifExtCode);
-int EGifPutExtensionBlock(GifFileType *GifFile,
-                         const int GifExtLen, const void *GifExtension);
+int EGifPutExtensionBlock(GifFileType *GifFile, const int GifExtLen,
+                          const void *GifExtension);
 int EGifPutExtensionTrailer(GifFileType *GifFile);
 int EGifPutExtension(GifFileType *GifFile, const int GifExtCode,
-                     const int GifExtLen,
-                     const void *GifExtension);
+                     const int GifExtLen, const void *GifExtension);
 int EGifPutCode(GifFileType *GifFile, int GifCodeSize,
                 const GifByteType *GifCodeBlock);
-int EGifPutCodeNext(GifFileType *GifFile,
-                    const GifByteType *GifCodeBlock);
+int EGifPutCodeNext(GifFileType *GifFile, const GifByteType *GifCodeBlock);
 
 /******************************************************************************
  GIF decoding routines
@@ -212,24 +210,25 @@ int EGifPutCodeNext(GifFileType *GifFile,
 /* Main entry points */
 GifFileType *DGifOpenFileName(const char *GifFileName, int *Error);
 GifFileType *DGifOpenFileHandle(int GifFileHandle, int *Error);
-int DGifSlurp(GifFileType * GifFile);
-GifFileType *DGifOpen(void *userPtr, InputFunc readFunc, int *Error);    /* new one (TVT) */
-    int DGifCloseFile(GifFileType * GifFile, int *ErrorCode);
-
-#define D_GIF_SUCCEEDED          0
-#define D_GIF_ERR_OPEN_FAILED    101    /* And DGif possible errors. */
-#define D_GIF_ERR_READ_FAILED    102
-#define D_GIF_ERR_NOT_GIF_FILE   103
-#define D_GIF_ERR_NO_SCRN_DSCR   104
-#define D_GIF_ERR_NO_IMAG_DSCR   105
-#define D_GIF_ERR_NO_COLOR_MAP   106
-#define D_GIF_ERR_WRONG_RECORD   107
-#define D_GIF_ERR_DATA_TOO_BIG   108
+int DGifSlurp(GifFileType *GifFile);
+GifFileType *DGifOpen(void *userPtr, InputFunc readFunc,
+                      int *Error); /* new one (TVT) */
+int DGifCloseFile(GifFileType *GifFile, int *ErrorCode);
+
+#define D_GIF_SUCCEEDED 0
+#define D_GIF_ERR_OPEN_FAILED 101 /* And DGif possible errors. */
+#define D_GIF_ERR_READ_FAILED 102
+#define D_GIF_ERR_NOT_GIF_FILE 103
+#define D_GIF_ERR_NO_SCRN_DSCR 104
+#define D_GIF_ERR_NO_IMAG_DSCR 105
+#define D_GIF_ERR_NO_COLOR_MAP 106
+#define D_GIF_ERR_WRONG_RECORD 107
+#define D_GIF_ERR_DATA_TOO_BIG 108
 #define D_GIF_ERR_NOT_ENOUGH_MEM 109
-#define D_GIF_ERR_CLOSE_FAILED   110
-#define D_GIF_ERR_NOT_READABLE   111
-#define D_GIF_ERR_IMAGE_DEFECT   112
-#define D_GIF_ERR_EOF_TOO_SOON   113
+#define D_GIF_ERR_CLOSE_FAILED 110
+#define D_GIF_ERR_NOT_READABLE 111
+#define D_GIF_ERR_IMAGE_DEFECT 112
+#define D_GIF_ERR_EOF_TOO_SOON 113
 
 /* These are legacy.  You probably do not want to call them directly */
 int DGifGetScreenDesc(GifFileType *GifFile);
@@ -247,11 +246,10 @@ int DGifGetCodeNext(GifFileType *GifFile, GifByteType **GifCodeBlock);
 int DGifGetLZCodes(GifFileType *GifFile, int *GifCode);
 const char *DGifGetGifVersion(GifFileType *GifFile);
 
-
 /******************************************************************************
  Error handling and reporting.
 ******************************************************************************/
-extern const char *GifErrorString(int ErrorCode);     /* new in 2012 - ESR */
+extern const char *GifErrorString(int ErrorCode); /* new in 2012 - ESR */
 
 /*****************************************************************************
  Everything below this point is new after version 1.2, supporting `slurp
@@ -263,26 +261,26 @@ extern const char *GifErrorString(int ErrorCode);     /* new in 2012 - ESR */
 ******************************************************************************/
 
 extern ColorMapObject *GifMakeMapObject(int ColorCount,
-                                     const GifColorType *ColorMap);
+                                        const GifColorType *ColorMap);
 extern void GifFreeMapObject(ColorMapObject *Object);
 extern ColorMapObject *GifUnionColorMap(const ColorMapObject *ColorIn1,
-                                     const ColorMapObject *ColorIn2,
-                                     GifPixelType ColorTransIn2[]);
+                                        const ColorMapObject *ColorIn2,
+                                        GifPixelType ColorTransIn2[]);
 extern int GifBitSize(int n);
 
 /******************************************************************************
  Support for the in-core structures allocation (slurp mode).
 ******************************************************************************/
 
-extern void GifApplyTranslation(SavedImage *Image, GifPixelType Translation[]);
+extern void GifApplyTranslation(SavedImage *Image,
+                                const GifPixelType Translation[]);
 extern int GifAddExtensionBlock(int *ExtensionBlock_Count,
-                                ExtensionBlock **ExtensionBlocks,
-                                int Function,
+                                ExtensionBlock **ExtensionBlocks, int Function,
                                 unsigned int Len, unsigned char ExtData[]);
 extern void GifFreeExtensions(int *ExtensionBlock_Count,
                               ExtensionBlock **ExtensionBlocks);
 extern SavedImage *GifMakeSavedImage(GifFileType *GifFile,
-                                  const SavedImage *CopyFrom);
+                                     const SavedImage *CopyFrom);
 extern void GifFreeSavedImages(GifFileType *GifFile);
 
 /******************************************************************************
@@ -295,37 +293,31 @@ int DGifExtensionToGCB(const size_t GifExtensionLength,
 size_t EGifGCBToExtension(const GraphicsControlBlock *GCB,
                           GifByteType *GifExtension);
 
-int DGifSavedExtensionToGCB(GifFileType *GifFile,
-                            int ImageIndex,
+int DGifSavedExtensionToGCB(GifFileType *GifFile, int ImageIndex,
                             GraphicsControlBlock *GCB);
 int EGifGCBToSavedExtension(const GraphicsControlBlock *GCB,
-                            GifFileType *GifFile,
-                            int ImageIndex);
+                            GifFileType *GifFile, int ImageIndex);
 
 /******************************************************************************
  The library's internal utility font
 ******************************************************************************/
 
-#define GIF_FONT_WIDTH  8
+#define GIF_FONT_WIDTH 8
 #define GIF_FONT_HEIGHT 8
 extern const unsigned char GifAsciiTable8x8[][GIF_FONT_WIDTH];
 
-extern void GifDrawText8x8(SavedImage *Image,
-                     const int x, const int y,
-                     const char *legend, const int color);
+extern void GifDrawText8x8(SavedImage *Image, const int x, const int y,
+                           const char *legend, const int color);
 
-extern void GifDrawBox(SavedImage *Image,
-                    const int x, const int y,
-                    const int w, const int d, const int color);
+extern void GifDrawBox(SavedImage *Image, const int x, const int y, const int w,
+                       const int d, const int color);
 
-extern void GifDrawRectangle(SavedImage *Image,
-                   const int x, const int y,
-                   const int w, const int d, const int color);
+extern void GifDrawRectangle(SavedImage *Image, const int x, const int y,
+                             const int w, const int d, const int color);
 
-extern void GifDrawBoxedText8x8(SavedImage *Image,
-                          const int x, const int y,
-                          const char *legend,
-                          const int border, const int bg, const int fg);
+extern void GifDrawBoxedText8x8(SavedImage *Image, const int x, const int y,
+                                const char *legend, const int border,
+                                const int bg, const int fg);
 
 #ifdef __cplusplus
 }
diff --git a/jdk/src/share/native/sun/awt/giflib/gif_lib_private.h b/jdk/src/share/native/sun/awt/giflib/gif_lib_private.h
index 4f832676ff..f905e0d7b4 100644
--- a/jdk/src/share/native/sun/awt/giflib/gif_lib_private.h
+++ b/jdk/src/share/native/sun/awt/giflib/gif_lib_private.h
@@ -33,52 +33,54 @@ SPDX-License-Identifier: MIT
 #ifndef _GIF_LIB_PRIVATE_H
 #define _GIF_LIB_PRIVATE_H
 
-#include "gif_lib.h"
 #include "gif_hash.h"
+#include "gif_lib.h"
 
 #ifndef SIZE_MAX
-    #define SIZE_MAX     UINTPTR_MAX
+#define SIZE_MAX UINTPTR_MAX
 #endif
 
-#define EXTENSION_INTRODUCER      0x21
-#define DESCRIPTOR_INTRODUCER     0x2c
-#define TERMINATOR_INTRODUCER     0x3b
+#define EXTENSION_INTRODUCER 0x21
+#define DESCRIPTOR_INTRODUCER 0x2c
+#define TERMINATOR_INTRODUCER 0x3b
 
-#define LZ_MAX_CODE         4095    /* Biggest code possible in 12 bits. */
-#define LZ_BITS             12
+#define LZ_MAX_CODE 4095 /* Biggest code possible in 12 bits. */
+#define LZ_BITS 12
 
-#define FLUSH_OUTPUT        4096    /* Impossible code, to signal flush. */
-#define FIRST_CODE          4097    /* Impossible code, to signal first. */
-#define NO_SUCH_CODE        4098    /* Impossible code, to signal empty. */
+#define FLUSH_OUTPUT 4096 /* Impossible code, to signal flush. */
+#define FIRST_CODE 4097   /* Impossible code, to signal first. */
+#define NO_SUCH_CODE 4098 /* Impossible code, to signal empty. */
 
-#define FILE_STATE_WRITE    0x01
-#define FILE_STATE_SCREEN   0x02
-#define FILE_STATE_IMAGE    0x04
-#define FILE_STATE_READ     0x08
+#define FILE_STATE_WRITE 0x01
+#define FILE_STATE_SCREEN 0x02
+#define FILE_STATE_IMAGE 0x04
+#define FILE_STATE_READ 0x08
 
-#define IS_READABLE(Private)    (Private->FileState & FILE_STATE_READ)
-#define IS_WRITEABLE(Private)   (Private->FileState & FILE_STATE_WRITE)
+#define IS_READABLE(Private) (Private->FileState & FILE_STATE_READ)
+#define IS_WRITEABLE(Private) (Private->FileState & FILE_STATE_WRITE)
 
 typedef struct GifFilePrivateType {
-    GifWord FileState, FileHandle,  /* Where all this data goes to! */
-      BitsPerPixel,     /* Bits per pixel (Codes uses at least this + 1). */
-      ClearCode,   /* The CLEAR LZ code. */
-      EOFCode,     /* The EOF LZ code. */
-      RunningCode, /* The next code algorithm can generate. */
-      RunningBits, /* The number of bits required to represent RunningCode. */
-      MaxCode1,    /* 1 bigger than max. possible code, in RunningBits bits. */
-      LastCode,    /* The code before the current code. */
-      CrntCode,    /* Current algorithm code. */
-      StackPtr,    /* For character stack (see below). */
-      CrntShiftState;    /* Number of bits in CrntShiftDWord. */
-    unsigned long CrntShiftDWord;   /* For bytes decomposition into codes. */
-    unsigned long PixelCount;   /* Number of pixels in image. */
-    FILE *File;    /* File as stream. */
-    InputFunc Read;     /* function to read gif input (TVT) */
-    OutputFunc Write;   /* function to write gif output (MRB) */
-    GifByteType Buf[256];   /* Compressed input is buffered here. */
+    GifWord FileState, FileHandle, /* Where all this data goes to! */
+        BitsPerPixel, /* Bits per pixel (Codes uses at least this + 1). */
+        ClearCode,    /* The CLEAR LZ code. */
+        EOFCode,      /* The EOF LZ code. */
+        RunningCode,  /* The next code algorithm can generate. */
+        RunningBits,  /* The number of bits required to represent
+                         RunningCode. */
+        MaxCode1, /* 1 bigger than max. possible code, in RunningBits bits.
+                   */
+        LastCode, /* The code before the current code. */
+        CrntCode, /* Current algorithm code. */
+        StackPtr, /* For character stack (see below). */
+        CrntShiftState;           /* Number of bits in CrntShiftDWord. */
+    unsigned long CrntShiftDWord; /* For bytes decomposition into codes. */
+    unsigned long PixelCount;     /* Number of pixels in image. */
+    FILE *File;                   /* File as stream. */
+    InputFunc Read;               /* function to read gif input (TVT) */
+    OutputFunc Write;             /* function to write gif output (MRB) */
+    GifByteType Buf[256];         /* Compressed input is buffered here. */
     GifByteType Stack[LZ_MAX_CODE]; /* Decoded pixels are stacked here. */
-    GifByteType Suffix[LZ_MAX_CODE + 1];    /* So we can trace the codes. */
+    GifByteType Suffix[LZ_MAX_CODE + 1]; /* So we can trace the codes. */
     GifPrefixType Prefix[LZ_MAX_CODE + 1];
     GifHashTableType *HashTable;
     bool gif89;
diff --git a/jdk/src/share/native/sun/awt/giflib/gifalloc.c b/jdk/src/share/native/sun/awt/giflib/gifalloc.c
index 75b74b4fba..5aef304455 100644
--- a/jdk/src/share/native/sun/awt/giflib/gifalloc.c
+++ b/jdk/src/share/native/sun/awt/giflib/gifalloc.c
@@ -30,59 +30,59 @@ SPDX-License-Identifier: MIT
 
 ****************************************************************************/
 
-#include <stdlib.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 
 #include "gif_lib.h"
 #include "gif_lib_private.h"
 
-#define MAX(x, y)    (((x) > (y)) ? (x) : (y))
+#define MAX(x, y) (((x) > (y)) ? (x) : (y))
 
 /******************************************************************************
  Miscellaneous utility functions
 ******************************************************************************/
 
 /* return smallest bitfield size n will fit in */
-int
-GifBitSize(int n)
-{
+int GifBitSize(int n) {
     register int i;
 
-    for (i = 1; i <= 8; i++)
-        if ((1 << i) >= n)
+    for (i = 1; i <= 8; i++) {
+        if ((1 << i) >= n) {
             break;
+        }
+    }
     return (i);
 }
 
 /******************************************************************************
-  Color map object functions
+ Color map object functions
 ******************************************************************************/
 
 /*
  * Allocate a color map of given size; initialize with contents of
  * ColorMap if that pointer is non-NULL.
  */
-ColorMapObject *
-GifMakeMapObject(int ColorCount, const GifColorType *ColorMap)
-{
+ColorMapObject *GifMakeMapObject(int ColorCount, const GifColorType *ColorMap) {
     ColorMapObject *Object;
 
     /*** FIXME: Our ColorCount has to be a power of two.  Is it necessary to
-     * make the user know that or should we automatically round up instead? */
+     * make the user know that or should we automatically round up instead?
+     */
     if (ColorCount != (1 << GifBitSize(ColorCount))) {
-        return ((ColorMapObject *) NULL);
+        return ((ColorMapObject *)NULL);
     }
 
     Object = (ColorMapObject *)malloc(sizeof(ColorMapObject));
-    if (Object == (ColorMapObject *) NULL) {
-        return ((ColorMapObject *) NULL);
+    if (Object == (ColorMapObject *)NULL) {
+        return ((ColorMapObject *)NULL);
     }
 
-    Object->Colors = (GifColorType *)calloc(ColorCount, sizeof(GifColorType));
-    if (Object->Colors == (GifColorType *) NULL) {
+    Object->Colors =
+        (GifColorType *)calloc(ColorCount, sizeof(GifColorType));
+    if (Object->Colors == (GifColorType *)NULL) {
         free(Object);
-        return ((ColorMapObject *) NULL);
+        return ((ColorMapObject *)NULL);
     }
 
     Object->ColorCount = ColorCount;
@@ -90,19 +90,17 @@ GifMakeMapObject(int ColorCount, const GifColorType *ColorMap)
     Object->SortFlag = false;
 
     if (ColorMap != NULL) {
-        memcpy((char *)Object->Colors,
-               (char *)ColorMap, ColorCount * sizeof(GifColorType));
+        memcpy((char *)Object->Colors, (char *)ColorMap,
+               ColorCount * sizeof(GifColorType));
     }
 
     return (Object);
 }
 
 /*******************************************************************************
-Free a color map object
+ Free a color map object
 *******************************************************************************/
-void
-GifFreeMapObject(ColorMapObject *Object)
-{
+void GifFreeMapObject(ColorMapObject *Object) {
     if (Object != NULL) {
         (void)free(Object->Colors);
         (void)free(Object);
@@ -110,17 +108,14 @@ GifFreeMapObject(ColorMapObject *Object)
 }
 
 #ifdef DEBUG
-void
-DumpColorMap(ColorMapObject *Object,
-             FILE * fp)
-{
+void DumpColorMap(ColorMapObject *Object, FILE *fp) {
     if (Object != NULL) {
         int i, j, Len = Object->ColorCount;
 
         for (i = 0; i < Len; i += 4) {
             for (j = 0; j < 4 && j < Len; j++) {
-                (void)fprintf(fp, "%3d: %02x %02x %02x   ", i + j,
-                              Object->Colors[i + j].Red,
+                (void)fprintf(fp, "%3d: %02x %02x %02x   ",
+                              i + j, Object->Colors[i + j].Red,
                               Object->Colors[i + j].Green,
                               Object->Colors[i + j].Blue);
             }
@@ -137,11 +132,9 @@ DumpColorMap(ColorMapObject *Object,
  copied iff they didn't exist before.  ColorTransIn2 maps the old
  ColorIn2 into the ColorUnion color map table./
 *******************************************************************************/
-ColorMapObject *
-GifUnionColorMap(const ColorMapObject *ColorIn1,
-              const ColorMapObject *ColorIn2,
-              GifPixelType ColorTransIn2[])
-{
+ColorMapObject *GifUnionColorMap(const ColorMapObject *ColorIn1,
+                                 const ColorMapObject *ColorIn2,
+                                 GifPixelType ColorTransIn2[]) {
     int i, j, CrntSlot, RoundUpTo, NewGifBitSize;
     ColorMapObject *ColorUnion;
 
@@ -152,17 +145,19 @@ GifUnionColorMap(const ColorMapObject *ColorIn1,
      */
 
     /* Allocate table which will hold the result for sure. */
-    ColorUnion = GifMakeMapObject(MAX(ColorIn1->ColorCount,
-                               ColorIn2->ColorCount) * 2, NULL);
+    ColorUnion = GifMakeMapObject(
+        MAX(ColorIn1->ColorCount, ColorIn2->ColorCount) * 2, NULL);
 
-    if (ColorUnion == NULL)
+    if (ColorUnion == NULL) {
         return (NULL);
+    }
 
     /*
      * Copy ColorIn1 to ColorUnion.
      */
-    for (i = 0; i < ColorIn1->ColorCount; i++)
+    for (i = 0; i < ColorIn1->ColorCount; i++) {
         ColorUnion->Colors[i] = ColorIn1->Colors[i];
+    }
     CrntSlot = ColorIn1->ColorCount;
 
     /*
@@ -172,22 +167,25 @@ GifUnionColorMap(const ColorMapObject *ColorIn1,
      * of table 1.  This is very useful if your display is limited to
      * 16 colors.
      */
-    while (ColorIn1->Colors[CrntSlot - 1].Red == 0
-           && ColorIn1->Colors[CrntSlot - 1].Green == 0
-           && ColorIn1->Colors[CrntSlot - 1].Blue == 0)
+    while (ColorIn1->Colors[CrntSlot - 1].Red == 0 &&
+           ColorIn1->Colors[CrntSlot - 1].Green == 0 &&
+           ColorIn1->Colors[CrntSlot - 1].Blue == 0) {
         CrntSlot--;
+    }
 
     /* Copy ColorIn2 to ColorUnion (use old colors if they exist): */
     for (i = 0; i < ColorIn2->ColorCount && CrntSlot <= 256; i++) {
         /* Let's see if this color already exists: */
-        for (j = 0; j < ColorIn1->ColorCount; j++)
-            if (memcmp (&ColorIn1->Colors[j], &ColorIn2->Colors[i],
-                        sizeof(GifColorType)) == 0)
+        for (j = 0; j < ColorIn1->ColorCount; j++) {
+            if (memcmp(&ColorIn1->Colors[j], &ColorIn2->Colors[i],
+                       sizeof(GifColorType)) == 0) {
                 break;
+            }
+        }
 
-        if (j < ColorIn1->ColorCount)
-            ColorTransIn2[i] = j;    /* color exists in Color1 */
-        else {
+        if (j < ColorIn1->ColorCount) {
+            ColorTransIn2[i] = j; /* color exists in Color1 */
+        } else {
             /* Color is new - copy it to a new slot: */
             ColorUnion->Colors[CrntSlot] = ColorIn2->Colors[i];
             ColorTransIn2[i] = CrntSlot++;
@@ -196,7 +194,7 @@ GifUnionColorMap(const ColorMapObject *ColorIn1,
 
     if (CrntSlot > 256) {
         GifFreeMapObject(ColorUnion);
-        return ((ColorMapObject *) NULL);
+        return ((ColorMapObject *)NULL);
     }
 
     NewGifBitSize = GifBitSize(CrntSlot);
@@ -210,16 +208,17 @@ GifUnionColorMap(const ColorMapObject *ColorIn1,
          * We know these slots exist because of the way ColorUnion's
          * start dimension was computed.
          */
-        for (j = CrntSlot; j < RoundUpTo; j++)
+        for (j = CrntSlot; j < RoundUpTo; j++) {
             Map[j].Red = Map[j].Green = Map[j].Blue = 0;
+        }
 
         /* perhaps we can shrink the map? */
         if (RoundUpTo < ColorUnion->ColorCount) {
-            GifColorType *new_map = (GifColorType *)reallocarray(Map,
-                                 RoundUpTo, sizeof(GifColorType));
-            if( new_map == NULL ) {
+            GifColorType *new_map = (GifColorType *)reallocarray(
+                Map, RoundUpTo, sizeof(GifColorType));
+            if (new_map == NULL) {
                 GifFreeMapObject(ColorUnion);
-                return ((ColorMapObject *) NULL);
+                return ((ColorMapObject *)NULL);
             }
             ColorUnion->Colors = new_map;
         }
@@ -234,49 +233,49 @@ GifUnionColorMap(const ColorMapObject *ColorIn1,
 /*******************************************************************************
  Apply a given color translation to the raster bits of an image
 *******************************************************************************/
-void
-GifApplyTranslation(SavedImage *Image, GifPixelType Translation[])
-{
+void GifApplyTranslation(SavedImage *Image, const GifPixelType Translation[]) {
     register int i;
-    register int RasterSize = Image->ImageDesc.Height * Image->ImageDesc.Width;
+    register int RasterSize =
+        Image->ImageDesc.Height * Image->ImageDesc.Width;
 
-    for (i = 0; i < RasterSize; i++)
+    for (i = 0; i < RasterSize; i++) {
         Image->RasterBits[i] = Translation[Image->RasterBits[i]];
+    }
 }
 
 /******************************************************************************
  Extension record functions
 ******************************************************************************/
-int
-GifAddExtensionBlock(int *ExtensionBlockCount,
-                     ExtensionBlock **ExtensionBlocks,
-                     int Function,
-                     unsigned int Len,
-                     unsigned char ExtData[])
-{
+int GifAddExtensionBlock(int *ExtensionBlockCount,
+                         ExtensionBlock **ExtensionBlocks, int Function,
+                         unsigned int Len, unsigned char ExtData[]) {
     ExtensionBlock *ep;
 
-    if (*ExtensionBlocks == NULL)
-        *ExtensionBlocks=(ExtensionBlock *)malloc(sizeof(ExtensionBlock));
-    else {
-        ExtensionBlock* ep_new = (ExtensionBlock *)reallocarray
-                                      (*ExtensionBlocks, (*ExtensionBlockCount + 1),
-                                      sizeof(ExtensionBlock));
-        if( ep_new == NULL )
+    if (*ExtensionBlocks == NULL) {
+        *ExtensionBlocks =
+            (ExtensionBlock *)malloc(sizeof(ExtensionBlock));
+    } else {
+        ExtensionBlock *ep_new = (ExtensionBlock *)reallocarray(
+            *ExtensionBlocks, (*ExtensionBlockCount + 1),
+            sizeof(ExtensionBlock));
+        if (ep_new == NULL) {
             return (GIF_ERROR);
+        }
         *ExtensionBlocks = ep_new;
     }
 
-    if (*ExtensionBlocks == NULL)
+    if (*ExtensionBlocks == NULL) {
         return (GIF_ERROR);
+    }
 
     ep = &(*ExtensionBlocks)[(*ExtensionBlockCount)++];
 
     ep->Function = Function;
-    ep->ByteCount=Len;
+    ep->ByteCount = Len;
     ep->Bytes = (GifByteType *)malloc(ep->ByteCount);
-    if (ep->Bytes == NULL)
+    if (ep->Bytes == NULL) {
         return (GIF_ERROR);
+    }
 
     if (ExtData != NULL) {
         memcpy(ep->Bytes, ExtData, Len);
@@ -285,38 +284,36 @@ GifAddExtensionBlock(int *ExtensionBlockCount,
     return (GIF_OK);
 }
 
-void
-GifFreeExtensions(int *ExtensionBlockCount,
-                  ExtensionBlock **ExtensionBlocks)
-{
+void GifFreeExtensions(int *ExtensionBlockCount,
+                       ExtensionBlock **ExtensionBlocks) {
     ExtensionBlock *ep;
 
-    if (*ExtensionBlocks == NULL)
+    if (*ExtensionBlocks == NULL) {
         return;
+    }
 
     for (ep = *ExtensionBlocks;
-         ep < (*ExtensionBlocks + *ExtensionBlockCount);
-         ep++)
+         ep < (*ExtensionBlocks + *ExtensionBlockCount); ep++) {
         (void)free((char *)ep->Bytes);
+    }
     (void)free((char *)*ExtensionBlocks);
     *ExtensionBlocks = NULL;
     *ExtensionBlockCount = 0;
 }
 
 /******************************************************************************
- Image block allocation functions
+   Image block allocation functions
 ******************************************************************************/
 
 /* Private Function:
  * Frees the last image in the GifFile->SavedImages array
  */
-void
-FreeLastSavedImage(GifFileType *GifFile)
-{
+void FreeLastSavedImage(GifFileType *GifFile) {
     SavedImage *sp;
 
-    if ((GifFile == NULL) || (GifFile->SavedImages == NULL))
+    if ((GifFile == NULL) || (GifFile->SavedImages == NULL)) {
         return;
+    }
 
     /* Remove one SavedImage from the GifFile */
     GifFile->ImageCount--;
@@ -329,54 +326,58 @@ FreeLastSavedImage(GifFileType *GifFile)
     }
 
     /* Deallocate the image data */
-    if (sp->RasterBits != NULL)
+    if (sp->RasterBits != NULL) {
         free((char *)sp->RasterBits);
+    }
 
     /* Deallocate any extensions */
     GifFreeExtensions(&sp->ExtensionBlockCount, &sp->ExtensionBlocks);
 
     /*** FIXME: We could realloc the GifFile->SavedImages structure but is
      * there a point to it? Saves some memory but we'd have to do it every
-     * time.  If this is used in GifFreeSavedImages then it would be inefficient
-     * (The whole array is going to be deallocated.)  If we just use it when
-     * we want to free the last Image it's convenient to do it here.
+     * time.  If this is used in GifFreeSavedImages then it would be
+     * inefficient (The whole array is going to be deallocated.)  If we just
+     * use it when we want to free the last Image it's convenient to do it
+     * here.
      */
 }
 
 /*
  * Append an image block to the SavedImages array
  */
-SavedImage *
-GifMakeSavedImage(GifFileType *GifFile, const SavedImage *CopyFrom)
-{
-    if (GifFile->SavedImages == NULL)
+SavedImage *GifMakeSavedImage(GifFileType *GifFile,
+                              const SavedImage *CopyFrom) {
+    // cppcheck-suppress ctunullpointer
+    if (GifFile->SavedImages == NULL) {
         GifFile->SavedImages = (SavedImage *)malloc(sizeof(SavedImage));
-    else {
-        SavedImage* newSavedImages = (SavedImage *)reallocarray(GifFile->SavedImages,
-                               (GifFile->ImageCount + 1), sizeof(SavedImage));
-        if( newSavedImages == NULL)
+    } else {
+        SavedImage *newSavedImages = (SavedImage *)reallocarray(
+            GifFile->SavedImages, (GifFile->ImageCount + 1),
+            sizeof(SavedImage));
+        if (newSavedImages == NULL) {
             return ((SavedImage *)NULL);
+        }
         GifFile->SavedImages = newSavedImages;
     }
-    if (GifFile->SavedImages == NULL)
+    if (GifFile->SavedImages == NULL) {
         return ((SavedImage *)NULL);
-    else {
+    } else {
         SavedImage *sp = &GifFile->SavedImages[GifFile->ImageCount++];
 
         if (CopyFrom != NULL) {
             memcpy((char *)sp, CopyFrom, sizeof(SavedImage));
 
             /*
-             * Make our own allocated copies of the heap fields in the
-             * copied record.  This guards against potential aliasing
-             * problems.
+             * Make our own allocated copies of the heap fields in
+             * the copied record.  This guards against potential
+             * aliasing problems.
              */
 
             /* first, the local color map */
             if (CopyFrom->ImageDesc.ColorMap != NULL) {
                 sp->ImageDesc.ColorMap = GifMakeMapObject(
-                                         CopyFrom->ImageDesc.ColorMap->ColorCount,
-                                         CopyFrom->ImageDesc.ColorMap->Colors);
+                    CopyFrom->ImageDesc.ColorMap->ColorCount,
+                    CopyFrom->ImageDesc.ColorMap->Colors);
                 if (sp->ImageDesc.ColorMap == NULL) {
                     FreeLastSavedImage(GifFile);
                     return (SavedImage *)(NULL);
@@ -384,32 +385,36 @@ GifMakeSavedImage(GifFileType *GifFile, const SavedImage *CopyFrom)
             }
 
             /* next, the raster */
-            sp->RasterBits = (unsigned char *)reallocarray(NULL,
-                                                  (CopyFrom->ImageDesc.Height *
-                                                  CopyFrom->ImageDesc.Width),
-                                                  sizeof(GifPixelType));
+            sp->RasterBits = (unsigned char *)reallocarray(
+                NULL,
+                (CopyFrom->ImageDesc.Height *
+                 CopyFrom->ImageDesc.Width),
+                sizeof(GifPixelType));
             if (sp->RasterBits == NULL) {
                 FreeLastSavedImage(GifFile);
                 return (SavedImage *)(NULL);
             }
             memcpy(sp->RasterBits, CopyFrom->RasterBits,
-                   sizeof(GifPixelType) * CopyFrom->ImageDesc.Height *
-                   CopyFrom->ImageDesc.Width);
+                   sizeof(GifPixelType) *
+                       CopyFrom->ImageDesc.Height *
+                       CopyFrom->ImageDesc.Width);
 
             /* finally, the extension blocks */
             if (CopyFrom->ExtensionBlocks != NULL) {
-                sp->ExtensionBlocks = (ExtensionBlock *)reallocarray(NULL,
-                                      CopyFrom->ExtensionBlockCount,
-                                      sizeof(ExtensionBlock));
+                sp->ExtensionBlocks =
+                    (ExtensionBlock *)reallocarray(
+                        NULL, CopyFrom->ExtensionBlockCount,
+                        sizeof(ExtensionBlock));
                 if (sp->ExtensionBlocks == NULL) {
                     FreeLastSavedImage(GifFile);
                     return (SavedImage *)(NULL);
                 }
-                memcpy(sp->ExtensionBlocks, CopyFrom->ExtensionBlocks,
-                       sizeof(ExtensionBlock) * CopyFrom->ExtensionBlockCount);
+                memcpy(sp->ExtensionBlocks,
+                       CopyFrom->ExtensionBlocks,
+                       sizeof(ExtensionBlock) *
+                           CopyFrom->ExtensionBlockCount);
             }
-        }
-        else {
+        } else {
             memset((char *)sp, '\0', sizeof(SavedImage));
         }
 
@@ -417,9 +422,7 @@ GifMakeSavedImage(GifFileType *GifFile, const SavedImage *CopyFrom)
     }
 }
 
-void
-GifFreeSavedImages(GifFileType *GifFile)
-{
+void GifFreeSavedImages(GifFileType *GifFile) {
     SavedImage *sp;
 
     if ((GifFile == NULL) || (GifFile->SavedImages == NULL)) {
@@ -432,10 +435,12 @@ GifFreeSavedImages(GifFileType *GifFile)
             sp->ImageDesc.ColorMap = NULL;
         }
 
-        if (sp->RasterBits != NULL)
+        if (sp->RasterBits != NULL) {
             free((char *)sp->RasterBits);
+        }
 
-        GifFreeExtensions(&sp->ExtensionBlockCount, &sp->ExtensionBlocks);
+        GifFreeExtensions(&sp->ExtensionBlockCount,
+                          &sp->ExtensionBlocks);
     }
     free((char *)GifFile->SavedImages);
     GifFile->SavedImages = NULL;
diff --git a/jdk/src/share/native/sun/awt/giflib/openbsd-reallocarray.c b/jdk/src/share/native/sun/awt/giflib/openbsd-reallocarray.c
index 452df69d7c..7420af674c 100644
--- a/jdk/src/share/native/sun/awt/giflib/openbsd-reallocarray.c
+++ b/jdk/src/share/native/sun/awt/giflib/openbsd-reallocarray.c
@@ -28,24 +28,22 @@
  * SPDX-License-Identifier: MIT
  */
 
-#include <sys/types.h>
 #include <errno.h>
 #include <stdint.h>
 #include <stdlib.h>
+#include <sys/types.h>
 
 #ifndef SIZE_MAX
-    #define SIZE_MAX     UINTPTR_MAX
+#define SIZE_MAX UINTPTR_MAX
 #endif
 
 /*
  * This is sqrt(SIZE_MAX+1), as s1*s2 <= SIZE_MAX
  * if both s1 < MUL_NO_OVERFLOW and s2 < MUL_NO_OVERFLOW
  */
-#define MUL_NO_OVERFLOW    ((size_t)1 << (sizeof(size_t) * 4))
+#define MUL_NO_OVERFLOW ((size_t)1 << (sizeof(size_t) * 4))
 
-void *
-openbsd_reallocarray(void *optr, size_t nmemb, size_t size)
-{
+void *openbsd_reallocarray(void *optr, size_t nmemb, size_t size) {
     if ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&
         nmemb > 0 && SIZE_MAX / nmemb < size) {
         errno = ENOMEM;
@@ -93,7 +91,8 @@ openbsd_reallocarray(void *optr, size_t nmemb, size_t size)
      * fuzzing on one platform may not detect zero-size allocation
      * problems on other platforms.
      */
-    if (size == 0 || nmemb == 0)
+    if (size == 0 || nmemb == 0) {
         return NULL;
+    }
     return realloc(optr, size * nmemb);
 }
